{"meta":{"title":"Hexo","subtitle":"","description":"","author":"wxy","url":"https://blog.ccuwxy.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-01-11T15:40:31.076Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"/404.html","permalink":"https://blog.ccuwxy.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-11T17:19:44.041Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"about/index.html","permalink":"https://blog.ccuwxy.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-01-11T15:40:31.108Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"books/index.html","permalink":"https://blog.ccuwxy.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-11T15:40:31.141Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ccuwxy.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-01-11T14:56:09.028Z","updated":"2021-01-11T13:18:23.598Z","comments":true,"path":"links/index.html","permalink":"https://blog.ccuwxy.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-11T14:54:43.416Z","updated":"2021-01-11T14:54:42.000Z","comments":false,"path":"repository/index.html","permalink":"https://blog.ccuwxy.cn/repository/index.html","excerpt":"","text":"Githubgithub: username: ccuwxy # github username"},{"title":"标签","date":"2021-01-11T15:40:31.173Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ccuwxy.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"PAT Basic Level 1012 数字分类（C++实现）","slug":"PAT-Basic-Level-1012-数字分类（C++实现）","date":"2021-09-01T09:00:02.000Z","updated":"2021-09-01T09:16:25.233Z","comments":true,"path":"f73146d3/","link":"","permalink":"https://blog.ccuwxy.cn/f73146d3/","excerpt":"","text":"给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：1213 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1：130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include &lt;iomanip&gt; using namespace std;int main()&#123; int N; int A1 = 0, A2 = 0, A3 = 0, A5 = 0; float A4 = 0; int count1 = 0, count2 = 0, count3 = 0, count4 = 0, count5 = 0; float sum4 = 0.0; cin &gt;&gt; N; int temp; int flag = 1; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; temp; if (temp % 5 == 0 &amp;&amp; temp % 2 == 0) &#123; count1++; A1 += temp; &#125; if (temp % 5 == 1) &#123; count2++; A2 += flag * temp; flag *= -1; &#125; if (temp % 5 == 2) &#123; count3++; A3++; &#125; if (temp % 5 == 3) &#123; count4++; sum4 += temp; &#125; if (temp % 5 == 4) &#123; count5++; A5 = A5 &gt; temp ? A5 : temp; &#125; &#125; A4 = (float)sum4 / count4; if (count1) cout &lt;&lt; A1 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count2) cout &lt;&lt; A2 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count3) cout &lt;&lt; A3 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count4) //printf(&quot;%0.1f &quot;, A4); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1) &lt;&lt; A4 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count5) cout &lt;&lt; A5; else cout &lt;&lt; &quot;N&quot;; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1013 数素数（C++实现）","slug":"PAT-Basic-Level-1013-数素数（C++实现）","date":"2021-09-01T08:30:05.000Z","updated":"2021-09-01T09:03:37.512Z","comments":true,"path":"8ce3536b/","link":"","permalink":"https://blog.ccuwxy.cn/8ce3536b/","excerpt":"","text":"令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10000，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 AC代码：素数：2 3 5 7 11 13 ……思路：每个数与除了1以外的整数相除，最大除数为√数，如果有能够整除的，就不是素数，反之为素数。设置一个数统计当前是第几个素数，当可以与10整除的时候输出换行，反之输出空格。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; int count = 0; int flag = 1; int c = 0; for (int i = 2; count &lt; n; i++) &#123; for (int j = 2; j &lt;= sqrt(i); j++) &#123; flag = 1; if (i % j == 0) &#123; flag = 0; break; &#125; &#125; if (flag) &#123; if (++count &gt;= m) &#123; cout &lt;&lt; i; if (++c % 10 == 0) cout &lt;&lt; endl; else if(count &lt; n) cout &lt;&lt; &quot; &quot;; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1071 小赌怡情（C++实现）","slug":"PAT-Basic-Level-1071-小赌怡情（C++实现）","date":"2021-03-07T03:20:05.000Z","updated":"2021-03-07T06:08:30.936Z","comments":true,"path":"6b819853/","link":"","permalink":"https://blog.ccuwxy.cn/6b819853/","excerpt":"","text":"常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。 注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式：输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字： 1n1 b t n2 其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式：对每一次游戏，根据下列情况对应输出（其中t是玩家下注量，x 是玩家当前持有的筹码量）： 玩家赢，输出 Win t! Total = x.；玩家输，输出 Lose t. Total = x.；玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.；玩家输光后，输出 Game Over. 并结束程序。 输入样例 1：12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例 1：1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. 输入样例 2：12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例 2：123Win 100! Total = 200.Lose 200. Total = 0.Game Over. AC代码(C++)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int main()&#123; int T, K; cin &gt;&gt; T &gt;&gt; K; for (int i = 0; i &lt; K; i++) &#123; if (T == 0) &#123; cout &lt;&lt; &quot;Game Over.&quot;; break; &#125; int n1, b, t, n2; cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2; if (t &gt; T) cout &lt;&lt; &quot;Not enough tokens. Total = &quot; &lt;&lt; T &lt;&lt;&quot;.&quot; &lt;&lt; endl; else &#123; if (b == 1) &#123; if (n2 &gt; n1) &#123; T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; else &#123; T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; &#125; else if (b == 0) &#123; if (n2 &lt; n1) &#123; T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; else &#123; T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; AC代码（Java）12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class T1071 &#123; public static void main(String[] args) &#123; int T,K; Scanner sc = new Scanner(System.in); T = sc.nextInt(); K = sc.nextInt(); for(int i = 0; i &lt; K;i++)&#123; if(T==0) &#123; System.out.print(&quot;Game Over.&quot;); break; &#125; int n1,b,t,n2; n1 = sc.nextInt(); b = sc.nextInt(); t = sc.nextInt(); n2 = sc.nextInt(); if(t &gt; T) System.out.println(&quot;Not enough tokens. Total = &quot;+T+&quot;.&quot;); else&#123; if(b==1)&#123; if(n2&gt;n1)&#123; T+=t; System.out.println(&quot;Win &quot;+t+&quot;! Total = &quot;+T+&quot;.&quot;); &#125;else&#123; T-=t; System.out.println(&quot;Lose &quot;+t+&quot;. Total = &quot;+T+&quot;.&quot;); &#125; &#125;else if(b==0)&#123; if(n2&lt;n1)&#123; T+=t; System.out.println(&quot;Win &quot;+t+&quot;! Total = &quot;+T+&quot;.&quot;); &#125;else&#123; T-=t; System.out.println(&quot;Lose &quot;+t+&quot;. Total = &quot;+T+&quot;.&quot;); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"选择法对数组中的整数按照从小到大排序","slug":"选择法对数组中的整数按照从小到大排序","date":"2021-03-06T03:00:05.000Z","updated":"2021-03-06T03:10:22.782Z","comments":true,"path":"9c73aafb/","link":"","permalink":"https://blog.ccuwxy.cn/9c73aafb/","excerpt":"","text":"思路首先将最小的数与a[0]对换；再将a[1]~a[n]中最小的数与a[1]对换……每比较一轮，找出一个最小的，共比较n-1轮。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int main()&#123; void sort(int array[], int n); int a[10]; for (int i = 0; i &lt; 10; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, 10); for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125;void sort(int array[], int n)&#123; int k, t; for (int i = 0; i &lt; n - 1; i++) &#123; k = i; for (int j = i + 1; j &lt; n; j++) &#123; if (array[j] &lt; array[k]) k = j; &#125; t = array[k]; array[k] = array[i]; array[i] = t; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1008 数组元素循环右移问题（C++实现）","slug":"PAT-Basic-Level-1008-数组元素循环右移问题（C++实现）","date":"2021-02-07T03:30:05.000Z","updated":"2021-02-07T03:38:59.690Z","comments":true,"path":"a786d318/","link":"","permalink":"https://blog.ccuwxy.cn/a786d318/","excerpt":"","text":"一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例:126 21 2 3 4 5 6 输出样例:15 6 1 2 3 4 AC代码思路：先全部逆置，然后前M个和后面N-M个分别逆置 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N, M; cin &gt;&gt; N &gt;&gt; M; int* nums = new int[N]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; nums[i]; M = M % N; int temp; for (int i = 0; i &lt; N / 2; i++) &#123; temp = nums[i]; nums[i] = nums[N - 1 - i]; nums[N - 1 - i] = temp; &#125; for (int i = 0; i &lt; M/2; i++) &#123; temp = nums[i]; nums[i] = nums[M - 1 - i]; nums[M - 1 - i] = temp; &#125; for (int i = M; i &lt; (N-M)/2+M; i++) &#123; temp = nums[i]; nums[i] = nums[N - 1 - i + M]; nums[N - 1 - i + M] = temp; &#125; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; nums[i]; if (i != N - 1) cout &lt;&lt; &quot; &quot;; &#125; delete[] nums; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1007 素数对猜想（C++实现）","slug":"PAT-Basic-Level-1007-素数对猜想（C++实现）","date":"2021-02-07T03:20:05.000Z","updated":"2021-02-07T03:07:54.798Z","comments":true,"path":"c37c6e1d/","link":"","permalink":"https://blog.ccuwxy.cn/c37c6e1d/","excerpt":"","text":"“素数对猜想”认为“存在无穷多对相邻且差为2的素数”现给定任意正整数N(&lt;10^5)，请计算不超过N的满足猜想的素数对的个数。 输入格式:输入在一行给出正整数N。 输出格式:在一行中输出不超过N的满足猜想的素数对的个数。 输入样例:120 输出样例:14 AC代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int N, count = 0; int temp = 0; cin &gt;&gt; N; int* nums = new int[N+1]&#123; 0 &#125;; int k = 0; for (int i = 2; i &lt;= N; i++) &#123; for (int j = 2; j &lt;= sqrt(i); j++) &#123; if (i % j == 0) &#123; temp = 1; break; &#125; &#125; if (temp == 0) nums[i] = 1; temp = 0; &#125; for (int i = 2; i &lt;= N-2; i++) &#123; if (nums[i] == 1 &amp;&amp; nums[i + 2] == 1) count++; &#125; cout &lt;&lt; count; delete []nums; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1006 换个格式输出整数(c++解法)","slug":"PAT-Basic-Level-1006-换个格式输出整数(c++解法)","date":"2021-01-25T06:52:05.000Z","updated":"2021-01-25T09:01:08.259Z","comments":true,"path":"b313ab2d/","link":"","permalink":"https://blog.ccuwxy.cn/b313ab2d/","excerpt":"","text":"让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12...n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式：每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式：每个测试用例的输出占一行，用规定的格式输出 n。 输入样例 1：1234 输出样例 1：1BBSSS1234 输入样例 2：123 输出样例 2：1SS123 代码123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int b = n / 100; int s = n % 100 / 10; int g = n % 10; while (b--) cout &lt;&lt; &#x27;B&#x27;; while (s--) cout &lt;&lt; &#x27;S&#x27;; for (int i = 1; i &lt;= g; i++) cout &lt;&lt; i; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Visual Studio 2019 创建C++项目并运行","slug":"Visual-Studio-2019-创建C++项目并运行","date":"2021-01-18T14:11:00.000Z","updated":"2021-01-18T14:27:55.469Z","comments":true,"path":"7df02547/","link":"","permalink":"https://blog.ccuwxy.cn/7df02547/","excerpt":"","text":"1. 点击创建新项目 2. 选择创建空项目 3. 输入项目名称、位置与解决方案名称4. 在解决方案资源管理器中的源文件点击右键，添加新建项 5. 选择C++文件，修改文件名称，添加即可6. 输入示例代码后，点击本地Windows调试器，运行即可","categories":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"}],"tags":[{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"}]},{"title":"leetcode 7. 整数反转","slug":"leetcode-7.-整数反转","date":"2021-01-17T07:20:05.000Z","updated":"2021-01-17T08:00:02.549Z","comments":true,"path":"9c180c02/","link":"","permalink":"https://blog.ccuwxy.cn/9c180c02/","excerpt":"","text":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意： 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^, 2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 示例 1：输入：x = 123输出：321 示例 2：输入：x = -123输出：-321 示例 3：输入：x = 120输出：21 示例 4：输入：x = 0输出：0 提示：-2^31^ &lt;= x &lt;= 2^31^ - 1 代码123456789101112131415class Solution &#123;public: int reverse(int x) &#123; long num = 0; while (x) &#123; num *= 10; num += (x % 10); x /= 10; &#125; return num &gt; INT_MAX || num &lt; INT_MIN ? 0 : num; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ccuwxy.cn/tags/leetcode/"}]},{"title":"leetcode 1. 两数之和","slug":"leetcode-1-两数之和","date":"2021-01-16T15:20:05.000Z","updated":"2021-01-17T06:37:30.621Z","comments":true,"path":"d9834ffe/","link":"","permalink":"https://blog.ccuwxy.cn/d9834ffe/","excerpt":"","text":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1：123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 示例 2：12输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2] 示例 3：12输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 代码1：123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i+1; j &lt; nums.size(); j++) &#123; if (nums.at(i) + nums.at(j) == target) return &#123;i, j&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 代码2（使用哈希表）：123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum1(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; auto it = hash.find(target - nums[i]); if (it != hash.end()) return &#123; it-&gt;second,i &#125;; hash[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ccuwxy.cn/tags/leetcode/"}]},{"title":"PAT Basic Level 1003 我要通过！(C++解法)","slug":"PAT-Basic-Level-1003-我要通过！(C++解法)","date":"2021-01-15T14:08:05.000Z","updated":"2021-01-15T14:27:14.799Z","comments":true,"path":"907368e/","link":"","permalink":"https://blog.ccuwxy.cn/907368e/","excerpt":"","text":"“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 输入样例：1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例：12345678YESYESYESYESNONONONO 代码及思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//由题意得，P前面只能有A#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n; string s; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; size_t p = s.find_first_not_of(&#x27;A&#x27;); // 找到第一个不是A的位置 if (p == string::npos || s[p] != &#x27;P&#x27;) //如果全是A或者最后一个A的后面不是P，则答案错误 &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; size_t t = s.find_first_not_of(&#x27;A&#x27;, p + 1); // 从p+1位置开始找不是A的位置，其实就是找T的位置 if (t == string::npos || s[t] != &#x27;T&#x27; || t == p + 1) //最后一个连续A的下一个不存在，或者不是T，或者P后面直接就是T，答案错误 &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; size_t m = s.find_first_not_of(&#x27;A&#x27;, t + 1);// 为了判断T后面有几个A， if (m != string::npos) // 如果T后面不全是A，则答案错误 &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; if ((s.length() - 1 - t) == p * (t - p - 1)) //T后面A的个数 等于 P前面A的个数 乘 P、T之间A的个数减一（由条件三判断） &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; continue; &#125; else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; &#125; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1004 成绩排名(c++解法)","slug":"PAT-Basic-Level-1004-成绩排名(c++解法)","date":"2021-01-14T14:52:05.000Z","updated":"2021-01-14T16:53:35.797Z","comments":true,"path":"f863b9d/","link":"","permalink":"https://blog.ccuwxy.cn/f863b9d/","excerpt":"","text":"读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 12345第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例：12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例：12Mike CS991301Joe Math990112 思路首先将姓名、学号、成绩放到一个结构体中，把输入的数据按照分数排序，输出即可。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct stu&#123; char name[11]; //这里比最大位数大一，也许需要保存文件结尾标记 char no[11]; int score;&#125;;bool cmp(stu a, stu b) // 将stu结构体按照score排序&#123; return a.score &lt; b.score; //从小到大&#125;int main()&#123; int n; cin &gt;&gt; n; stu* stus = new stu[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stus[i].name &gt;&gt; stus[i].no &gt;&gt; stus[i].score; &#125; sort(stus, stus + n, cmp); cout &lt;&lt; stus[n - 1].name &lt;&lt; &quot; &quot; &lt;&lt; stus[n - 1].no &lt;&lt; endl; cout &lt;&lt; stus[0].name &lt;&lt; &quot; &quot; &lt;&lt; stus[0].no &lt;&lt; endl; delete[] stus; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1002 写出这个数(20分)","slug":"PAT-Basic-Level-1002-写出这个数(20分)","date":"2021-01-13T13:52:05.000Z","updated":"2021-01-14T16:53:35.796Z","comments":true,"path":"8edce93b/","link":"","permalink":"https://blog.ccuwxy.cn/8edce93b/","excerpt":"","text":"读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10^100 。 输出格式：在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：11234567890987654321123456789 输出样例：1yi san wu 思路输入数字最大100位，采用字符串输入，将每个字符对应的数字累加，按位取出累加和每位，将每位对应的拼音输出。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int main()&#123; string pinyin[10] = &#123; &quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot; &#125;; string N; cin &gt;&gt; N; int length = N.length(); int sum = 0; while (length) &#123; sum += (N[--length] - &#x27;0&#x27;); //在ASCII中字符与&#x27;0&#x27;字符的差值为对应的数字 &#125; char sumChar[3]; int sumIndex = 0; while (sum) &#123; sumChar[sumIndex++] = sum % 10; //存放的数字为逆序的 sum /= 10; &#125; for (int i = sumIndex - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; pinyin[sumChar[i]]; if (i != 0) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1001 害死人不偿命的(3n+1)猜想(15分)","slug":"PAT-Basic-Level-1001-害死人不偿命的(3n+1)猜想(15分)","date":"2021-01-13T13:20:05.000Z","updated":"2021-01-14T16:53:35.795Z","comments":true,"path":"ea4b0a04/","link":"","permalink":"https://blog.ccuwxy.cn/ea4b0a04/","excerpt":"","text":"卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：13 输出样例15 思路当n为偶数时，n变为n的一半；当n为奇数时，n变为3n+1的一半。记录n等于1需要运算的次数，输出即可。 代码1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int count = 0; int N; scanf(&quot;%d&quot;, &amp;N); while (N != 1) &#123; if (N % 2 == 0) &#123; N /= 2; &#125; else &#123; N = (3 * N + 1) / 2; &#125; count++; &#125; printf(&quot;%d&quot;, count); return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1066 图像过滤(15分)","slug":"PAT-Basic-Level-1066-图像过滤(15分)","date":"2021-01-13T11:21:05.000Z","updated":"2021-01-14T16:53:35.798Z","comments":true,"path":"f1334a6c/","link":"","permalink":"https://blog.ccuwxy.cn/f1334a6c/","excerpt":"","text":"图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 输入格式：输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。 输出格式输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。 输入样例12343 5 100 150 03 189 254 101 119150 233 151 99 10088 123 149 0 255 输出样例123003 189 254 000 000000 233 151 099 000088 000 000 000 255 思路当灰度值在A-B区间时，将灰度值替换为指定的灰度值，每个灰度值输出三位，空位补0 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; int M, N, A, B, re; cin &gt;&gt; M &gt;&gt; N &gt;&gt; A &gt;&gt; B &gt;&gt; re; int* rgbs = new int[N]; for (int i = 0; i &lt; M; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; cin &gt;&gt; rgbs[j]; if (rgbs[j] &gt;= A &amp;&amp; rgbs[j] &lt;= B) rgbs[j] = re; &#125; for (int j = 0; j &lt; N; j++) &#123; cout &lt;&lt; setw(3) &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; rgbs[j]; if (j != N - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1060 爱丁顿数 (25分)","slug":"PAT-Basic-Level-1060-爱丁顿数(25分)","date":"2021-01-13T03:01:00.000Z","updated":"2021-01-14T16:53:35.797Z","comments":true,"path":"d56ae534/","link":"","permalink":"https://blog.ccuwxy.cn/d56ae534/","excerpt":"","text":"英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式：输入第一行给出一个正整数 N (≤10^5)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式：在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 思路数据大小为10^5，不能使用O(N^2)时间复杂度的算法，采用先快排，再找爱丁顿数 废话不说了 上代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int N; cin &gt;&gt; N; int* nums = new int[N]; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + N); //从小到大快排 if (nums[0] &gt; N) //如果骑行距离最小对应的天数都大于骑行的天数，直接输出骑行的天数 cout &lt;&lt; N; else for (int i = N - 1; i &gt;= 0; i--) &#123; if (N - i &gt;= nums[i]) //找到天数大于等于元素值 &#123; cout &lt;&lt; N - i - 1; //去除当前元素对应的天数，输出天数-1 break; &#125; &#125; delete[] nums; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"解决Visual Studio 2019 下载扩展非常慢的问题！！！","slug":"解决Visual Studio 2019 下载扩展非常慢的问题！！！","date":"2021-01-13T02:30:00.000Z","updated":"2021-01-14T16:53:35.798Z","comments":true,"path":"a7f0f5d4/","link":"","permalink":"https://blog.ccuwxy.cn/a7f0f5d4/","excerpt":"","text":"解决思路（推荐使用下载工具下载到本地再安装）一、修改host文件（该方法效果因地理位置而不同）（不推荐） host文件位置：C:\\Windows\\System32\\drivers\\etc 通过站长工具http://tool.chinaz.com/dns 查询 download.visualstudio.microsoft.com 域名TTL值最小的IP地址 在最后一行加上 这个IP地址和域名122.188.0.118 download.visualstudio.microsoft.com 打开cmd命令行窗口 使用 ipconfig /flushdns 命令刷新DNS 重新下载扩展就可以了 二、使用下载工具下载到本地，再安装（推荐） 首先打开vs的管理扩展 在联机中找到想要下载的扩展，在右面栏中点击 详细信息 在网页中下载（推荐使用X雷等下载工具，会有P2P加速） 关闭VS，双击下载的文件安装即可","categories":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"}],"tags":[{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"}]},{"title":"计算机网络（一）","slug":"network","date":"2021-01-11T15:53:03.792Z","updated":"2021-01-14T16:53:00.356Z","comments":true,"path":"de1fcd2b/","link":"","permalink":"https://blog.ccuwxy.cn/de1fcd2b/","excerpt":"","text":"三次握手 第一次握手: client将标志位SYN置为1,随机产生一个值seq = J,并将该数据发送给server,client进入SYN_SENT状态,等待server确认 第二次握手: server收到数据包后由标志位SYN=1知道client 请求建立连接,server将标志位SYN和ACK都置为1, ack = J + 1, 随机产生一个值seq = K,并将该数据包发送给client以确认连接请求, server进入SYN_RCVD状态 第三次握手: client收到确认,检查ack是否为J+1， ACK是否为,如果正确则将标志位ACK置为1,ack = K+1, 并将该数据包发送给server, server检查ack是否为K+1, ACK是否为1,如果正确则连接建立成功, client和server进入ESTABLISHED状态,完成三次握手,随后client和server之间可以开始传输数据了 四次挥手 第一次挥手: client发送一个FIN,用来关闭client到server的数据传送,client进入FIN_WAIT_1状态 第二次挥手: server收到FIN后,发送一个ACK给client,确认序号为收到序号+1,server进入close_wait状态 第三次挥手: server发送一个FIN,用来关闭server到client的数据传送,server进入LAST_ACK状态 第四次挥手: client收到FIN后,client进入TIME_WAIT状态,接着发送一个ACK给server,确认序号为收到序号+1, server进入CLOSE状态,完成四次挥手 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 TCP和UDP区别 是否面向连接 传输可靠性 传输形式 传输效率 所需资源 应用场景 首部字节 TCP 面向连接 可靠 字节流 慢 多 要求传输可靠（文件传输） 20-60 UDP 无连接 不可靠 数据报文段 块 少 要求速度快（直播） 8字节 地址栏输入url到显示页面的过程 浏览器通过DNS查找域名对应的IP地址 浏览器向web服务器发送一个HTTP请求 服务器处理请求 服务器返回一个HTML响应 浏览器解析HTML渲染页面 状态码 类别 原因 1XX 信息状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 重定向状态码 需要进行附加操作 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器端错误状态码 服务器处理请求出错 Cookie和SessionCookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie一般用来存储用户信息，数据保存在客户端Session主要通过服务器记录用户的状态，数据保存在服务器 HTTP 和 HTTPS 的区别 端口：HTTP默认80端口；HTPS默认443端口； 完全性：HTTP协议运行在TCP上，所有的内容都是明文的；HTTPS是运行在SSL/TLS上的协议，所有的传输都经过了加密； 对称加密：密钥只有一个，加密解密同一个密码； 非对称加密：密钥是成对的，分为公钥和私钥，相对于对称加密，速度比较慢。 资源消耗：HTTP资源消耗比HTTPS资源消耗少。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://blog.ccuwxy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.ccuwxy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JVM","slug":"JVM","date":"2020-04-06T13:05:00.000Z","updated":"2021-01-14T16:53:00.349Z","comments":true,"path":"66c016fb/","link":"","permalink":"https://blog.ccuwxy.cn/66c016fb/","excerpt":"","text":"Java内存区域 JDK1.8之前： 线程共享：堆、方法区 线程私有：虚拟机栈、本地方法栈、程序计数器 JDK1.8： 线程共享：堆、元空间（直接内存） 线程私有：虚拟机栈、本地方法栈、程序计数器 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://blog.ccuwxy.cn/tags/JVM/"}]},{"title":"redis","slug":"redis","date":"2020-04-06T11:36:00.000Z","updated":"2021-01-14T16:53:00.356Z","comments":true,"path":"7b25d017/","link":"","permalink":"https://blog.ccuwxy.cn/7b25d017/","excerpt":"","text":"常用数据类型 String 常用命令: set,get,decr,incr,mget 等。 是简单的key-value类型。 Hash 常用命令: hget,hset,hgetall 等。 特别适合存储对象。 List 常用命令: lpush,rpush,lpop,rpop,lrange等。 list就是链表，可用作粉丝列表、消息列表 Set 常用命令: sadd,spop,smembers,sunion等。 set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。 Sorted Set 常用命令: zadd,zrange,zrem,zcard等。 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://blog.ccuwxy.cn/tags/redis/"}]},{"title":"MySQL联合索引(复合索引)的使用原则","slug":"mysql","date":"2020-04-06T11:30:00.000Z","updated":"2021-01-22T15:31:56.000Z","comments":true,"path":"c64d45f4/","link":"","permalink":"https://blog.ccuwxy.cn/c64d45f4/","excerpt":"","text":"ＭySQL联合 索引(复合索引)的使用原则命名规则：表名_字段名 需要加索引的字段，要在where条件中。 数据量少的字段不需要加索引。最窄的字段放在键的左边。 如果where条件中是OR关系，必须所有的or条件都必须是独立索引，否则加索引不起作用。 最左匹配原则。 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 聚簇索引与非聚簇索引（也叫二级索引） 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"联合索引","slug":"联合索引","permalink":"https://blog.ccuwxy.cn/tags/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"}]},{"title":"MySQL和Oracle的区别","slug":"mysql-oracle","date":"2020-04-06T11:30:00.000Z","updated":"2021-01-14T16:53:00.355Z","comments":true,"path":"eae41e22/","link":"","permalink":"https://blog.ccuwxy.cn/eae41e22/","excerpt":"","text":"事务的提交 mysql默认自动提交事务 oracle默认手动提交事务，通过commit来提交 分页查询 mysql用limit进行分页 oracle用伪列rownum和嵌套查询 事务隔离级别 mysql默认repeatable read oracle默认read committed 对事务的支持 mysql只有在InnoDB引擎时才支持事务 oracle任何情况都支持事务","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.ccuwxy.cn/tags/Oracle/"}]},{"title":"多线程（二）","slug":"thread02","date":"2020-04-05T14:05:00.000Z","updated":"2021-01-14T16:53:00.357Z","comments":true,"path":"36b886b6/","link":"","permalink":"https://blog.ccuwxy.cn/36b886b6/","excerpt":"","text":"ThreadLocal可以理解ThreadLocal是对ThreadLocalMap的封装，对ThreadLocal的set和get，其实都是对ThreadLocalMap的操作，Map的key是当前线程的Thread对象，值为Object对象。 ThreadLocal内存泄漏ThreadLocal 的key是弱引用，value是强引用，当ThreadLocal没有被外部强引用的时候，垃圾回收时，会把key清理掉，而value不会被清理掉，这样一来，value永远不会被回收，就造成了内存泄漏。 线程池池化技术只要是为了减少每次获取资源的消耗，提高对资源的利用率。 降低资源消耗。通过重复利用已经创建好的线程降低线程创建和销毁造成的资源消耗。 提高响应速度。不需要等待创建线程，直接在线程池中取线程。 提高线程的可管理性。线程池可以统一调配、调优、监控线程的使用。 实现Runnable接口和Callable接口的区别Runnable接口没有返回值，也不能抛出异常；而Callable接口有返回值，可以抛出异常。 ThreadPoolExecutor类分析123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; **corePoolSize**：核心线程数定义了最小可以同时运行的线程数量 **maximumPoolSize**：最大线程数。当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。 keepAliveTime：当线程池线程数量大于corePoolSize时，如果没有新的任务提交，核心线程外的线程不会被立即销毁，而是会等到超时时间过了keepAliveTime才会被销毁。 **workQueue**：当新任务来的时候，会先判断当前运行的线程数量是否达到核心线程数量，如果达到，就放入到队列中。 unit：keepAliveTime的时间单位。 threadFactory：executor创建新的线程时会用到。 handler：饱和策略。 ThreadPoolExecutor 饱和策略 **ThreadPoolExecutor.AbortPolicy**：抛出异常，拒绝新任务； **ThreadPoolExecutor.CallerRunsPolicy**：重试添加当前任务； ThreadPoolExecutor.DiscardPolicy： 丢掉当前任务； ThreadPoolExecutor.DiscardOldestPolicy： 丢掉最早未处理任务。 线程池原理首先提交任务，判断线程池满否，线程池满了，判断等待队列满否，等待队列满了，判断线程池满否，线程池满了，依照策略处理；线程池未满，创建线程；等待队列未满，加入到队列。 Atomic 原子类原子类是指一个操作是不可中断的，不会被其他的线程干扰。 原子类分类基本类型 AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型 AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新带有版本号的引用类型。 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 CAS原理CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。 AQS（AbstractQueuedSynchronizer）AQS在java.util.concurrent.locks包下，它是一个用来构建锁和同步器的框架，使用AQS可以简单高效的构造出应用广泛的同步器，比如ReentranLock。 AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 AQS两种资源共享方式 独占：只有一个线程能够执行。例如ReentrantLock。又可分为公平锁和非公平锁。 共享：多个线程可以同时执行。例如Semaphore。 AQS组件总结 Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 CountDownLatch（倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 CyclicBarrier(循环栅栏)： 实现线程间的技术等待。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]},{"title":"多线程（一）","slug":"thread01","date":"2020-04-04T14:05:00.000Z","updated":"2021-01-14T16:53:00.357Z","comments":true,"path":"6ae6a6e/","link":"","permalink":"https://blog.ccuwxy.cn/6ae6a6e/","excerpt":"","text":"进程？进程是程序的一次执行过程，是程序运行程序的基本单位，进程是动态的，程序的运行就是进程从创建到运行再到消亡的一个过程。 线程？线程和进程类似，线程是比进程更小的运行单位。一个进程的执行过程中可能会产生多个线程，同一个类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈、本地方法栈，在各个线程之间切换工作的负担要比进程小很多。 进程和线程的关系、区别、优缺点？线程是进程划分的更小的执行单位。他们最大的不同是 各个进程之间是独立的，而线程不一定。因为同一进程下的线程极有可能会相互影响。线程在切换时的开销要比进程小的多，但资源不利于管理，进程恰恰相反。 程序计数器为什么是私有的？程序计数器有以下两个作用： 程序计数器用来实现代码的流程控制。如：顺序执行、选择执行、循环执行。 在多线程的情况下，程序计数器可以记录当前线程执行到的位置，在线程切换回来的时候，知道执行到了哪里。 程序计数器是私有的是为了线程在切换回来时能够找到正确的执行位置。 虚拟机栈和本地方法栈为什么是私有的？虚拟机栈和本地方法栈私有为了保证线程中的局部变量不被其他线程访问到。 什么是堆和方法区？堆和方法区是线程共享的资源，堆是进程中最大的一块内存区域，主要用来存放新创建的对象，方法区用来存放已经被加载的类信息、常量、静态变量等数据。 并发和并行 并发： 同一时间段内，多个任务在执行； 并行： 同一个时间点，多个任务在执行。 为什要用多线程？ 从计算机底层来说： 线程可以比作轻量级的进程，是程序执行的最小单位，线程之间的上下文切换成本要比进程小得多。现在的CPU多数是多核心的，也就是多个线程可以同时运行，大大减少了上下文切换的开销。 互联网发展： 现在的系统经常有数百万，数千万的并发量，如果只用单线程肯定是扛不住的，多线程为高并发系统提供了基础，利用多线程层可以大大提高系统的应发能力。 多线程可能会带来哪些问题？在多线程的时候，可能会发生内存泄漏、上下文切换、死锁等问题。 线程的生命周期初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态 线程创建之后处于新建状态，调用了start()方法后处于可运行状态，当获取到了时间片后，处于运行状态。当线程执行了wait()方法后，处于等待状态，需要依靠其他线程来唤醒。当线程在没有获取到锁的时候，会处于阻塞状态，在执行run()方法后，会处于终止状态。 什么是死锁？死锁就是多个线程同时被阻塞，都在等待某个资源被释放。由于线程被无限期阻塞，就造成了死锁。 死锁需要具备的条件： 互斥条件：某资源同一时刻只能一个线程使用； 请求与保持条件：一个线程在请求资源被阻塞时，不会释放已获得资源； 不剥夺条件：一个线程已获得的资源，不能在未使用完之前被其他线程剥夺，只能自己使用完毕后释放； 循环等待条件：若干线程之间形成一种头尾相接的循环等待关系。 如何避免死锁？ 破坏互斥条件：（无法破坏锁的互斥） 破坏请求与保持条件：一次性申请所有资源； 破坏不剥夺条件：占用资源的线程如果获取不到资源，主动释放已经获得的资源； 破坏循环等待条件：按序申请资源。 sleep()和wait()的异同？ sleep()没有释放锁，而wait()释放了锁； 两者都可以暂停线程； wait()通常用来线程间的通讯，sleep()用来暂停执行； wait()在调用后不会自动苏醒，需要另一个线程来唤醒，sleep()在执行完后会自动苏醒，wait(long timeout)超时也会自动苏醒。 为什么我们要调用start()方法，不能直接调用run()方法？因为调用start()方法后，线程会进入到就绪状态，当有时间片的时候，会进入到运行状态；而run()只是个普通方法调用，会被当成普通方法执行。 synchronized关键字synchronized 关键字是用来解决多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或代码块在一个时间点 只有一个线程能访问执行。 synchronized关键字三种使用方式 修饰实例方法：对当前对象加锁 修饰静态方法：对当前类加锁 修饰代码块：对当前类加锁 JDK1.6之后synchronized关键字底层的优化偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除等等。 锁只能升级不能降级锁的四种状态： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 synchronized和ReentrantLock区别① 两者都是可重入锁 可重入锁指的是自己可以再次获取自己的内部锁。 ② synchronized依赖于JVM，而ReentrantLock依赖于API synchronized依赖于JVM层面实现的，而ReentrantLock需要Lock() 和unlock() 配合try/finally来实现的。 ③ ReentrantLock比 synchronized 增加了一些高级功能 ReentrantLock提供了一种等待锁的线程机制 ReentrantLock可以是公平锁也可以是非公平锁，synchronized只能是非公平锁。公平锁就是先等待的线程先获得锁。 volatile关键字1. Java内存模型在JDK1.2之前，Java的内存模型实现是总是从主存（共享内存）读取变量，不需要特别注意；但现在的内存模型实现，线程可以吧变量存在本地内存中，而不是从主存直接读取，这就可能造成主存中的变量被修改了，另一个线程还在使用内存中未被修改的数据进行操作。 2. 并发编程三个重要特性 原子性：一个操作或多次操作，要么全部执行，要么全部不执行，synchronized可以保证代码片段的原子性； 可见性：当一个线程对共享内存修改了，别的线程可以立即看到修改后的最新值； 有序性：代码在执行过程中的先后顺序，volatile关键字可以防止指令重排 3. synchronized关键字与volatile关键字区别 volatile关键字是线程同步的轻量级实现，性能要比synchronized关键字好，但是volatile只能修饰变量，而synchronized关键字可以修饰变量、方法、代码块； 多线程访问volatile关键字不会发生阻塞，而synchronized可能发生阻塞； volatile关键字能保证数据的可见性，不能保证数据的原子性，synchronized都可以保证； volatile关键字主要用来解决变量在多个线程之间的可见性，而synchronized关键字解决的是同步性。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://blog.ccuwxy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ccuwxy.cn/tags/leetcode/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.ccuwxy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JVM","slug":"JVM","permalink":"https://blog.ccuwxy.cn/tags/JVM/"},{"name":"redis","slug":"redis","permalink":"https://blog.ccuwxy.cn/tags/redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"联合索引","slug":"联合索引","permalink":"https://blog.ccuwxy.cn/tags/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.ccuwxy.cn/tags/Oracle/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]}