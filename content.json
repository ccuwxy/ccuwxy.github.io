{"meta":{"title":"Hexo","subtitle":"","description":"","author":"wxy","url":"https://blog.ccuwxy.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-01-11T15:40:31.076Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"/404.html","permalink":"https://blog.ccuwxy.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-11T17:19:44.041Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"about/index.html","permalink":"https://blog.ccuwxy.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-01-11T15:40:31.108Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"books/index.html","permalink":"https://blog.ccuwxy.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-11T15:40:31.141Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ccuwxy.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-01-11T14:56:09.028Z","updated":"2021-01-11T13:18:23.598Z","comments":true,"path":"links/index.html","permalink":"https://blog.ccuwxy.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-11T14:54:43.416Z","updated":"2021-01-11T14:54:42.000Z","comments":false,"path":"repository/index.html","permalink":"https://blog.ccuwxy.cn/repository/index.html","excerpt":"","text":"Githubgithub: username: ccuwxy # github username"},{"title":"标签","date":"2021-01-11T15:40:31.173Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ccuwxy.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Visual Studio 2019 创建MFC项目并运行","slug":"Visual-Studio-2019-创建MFC项目并运行","date":"2021-10-07T11:11:00.000Z","updated":"2021-10-07T11:22:52.590Z","comments":true,"path":"4fd4d11a/","link":"","permalink":"https://blog.ccuwxy.cn/4fd4d11a/","excerpt":"","text":"1. 点击创建新项目 2. 安装MFC（有MFC应用选项跳过）1） 点击安装多个工具和功能 2）点击适用于最新生成工具的C++MFC 3）点击安装就可以了3. 创建MFC应用1）点击MFC应用，并创建2）应用程序类型可以选择基于对话框，也可在用户界面功能中把关于框取消勾选 3）点击完成就创建好啦4.运行MFC应用","categories":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"}],"tags":[{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"}]},{"title":"邻接表+优先队列 prim算法求最小生成树","slug":"邻接表+优先队列 prim算法求最小生成树","date":"2021-10-07T07:20:05.000Z","updated":"2021-10-07T11:24:51.000Z","comments":true,"path":"5153622b/","link":"","permalink":"https://blog.ccuwxy.cn/5153622b/","excerpt":"","text":"样例输入123456760 3 1 6 2 1 3 51 3 0 6 2 5 4 32 5 0 1 1 5 3 5 4 6 5 43 3 0 5 2 5 5 44 3 1 3 2 6 5 65 3 4 6 2 4 3 2 样例输出115 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/*0:v11:v22:v33:v44:v55:v6输入：邻接表输出：最小生成树各边权值总和*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;static const int MAX = 10000;static const int INFTY = (1 &lt;&lt; 20);static const int WHITE = 0;static const int GRAY = 1;static const int BLACK = 2;int n;vector&lt;pair&lt;int, int&gt;&gt; adj[MAX]; //加权图的邻接表表示法int prim() &#123; priority_queue&lt;pair&lt;int, int&gt;&gt; PQ; int color[MAX]; int d[MAX]; int p[MAX]; for (int i = 0; i &lt; n; i++) &#123; d[i] = INFTY; p[i] = -1; color[i] = WHITE; &#125; d[0] = 0; PQ.push(make_pair(0, 0)); while (!PQ.empty()) &#123; pair&lt;int, int&gt; f = PQ.top(); PQ.pop(); int u = f.second; color[u] = BLACK; if (d[u] &lt; f.first * (-1)) continue; for (int j = 0; j &lt; adj[u].size(); j++) &#123; int v = adj[u][j].first; if (color[v] == BLACK) continue; if (d[v] &gt; adj[u][j].second) &#123; d[v] = adj[u][j].second; p[v] = adj[u][j].second; PQ.push(make_pair(d[v] * (-1), v)); color[v] = GRAY; &#125; &#125; &#125; int sum = 0; for (int i = 0; i &lt; n; i++) &#123; if (p[i] != -1) sum += p[i]; &#125; return sum;&#125;int main()&#123; int k, u, v, c; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; v &gt;&gt; c; adj[u].push_back(make_pair(v, c)); &#125; &#125; cout &lt;&lt; prim(); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"邻接表+优先队列 Dijkstra算法求解最短路径","slug":"邻接表+优先队列 Dijkstra算法求解最短路径","date":"2021-10-07T07:20:05.000Z","updated":"2021-10-07T11:25:52.000Z","comments":true,"path":"cacd962e/","link":"","permalink":"https://blog.ccuwxy.cn/cacd962e/","excerpt":"","text":"样例输入123456760 4 2 5 3 3 4 2 5 31 2 2 6 3 32 3 1 6 3 2 0 53 4 1 3 2 2 0 3 4 44 3 3 4 0 2 5 55 2 0 3 4 5 样例输出1234560 01 62 53 34 25 3 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778/*输入：邻接表输出：D到各个点的最短路径*/#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;queue&gt;using namespace std;static const int MAX = 10000;static const int INFTY = (1&lt;&lt;20);static const int WHITE = 0;static const int GRAY = 1;static const int BLACK = 2;int n;vector&lt;pair&lt;int, int&gt;&gt; adj[MAX]; //加权有向图的邻接表表示法void dijkstra() &#123; priority_queue&lt;pair&lt;int, int&gt;&gt; PQ; int color[MAX]; int d[MAX]; for (int i = 0; i &lt; n; i++) &#123; d[i] = INFTY; color[i] = WHITE; &#125; d[0] = 0; PQ.push(make_pair(0, 0)); color[0] = GRAY; while (!PQ.empty()) &#123; pair&lt;int, int&gt; f = PQ.top(); PQ.pop(); int u = f.second; color[u] = BLACK; //取出最小值，如果不是最短路径则忽略 if (d[u] &lt; f.first * (-1)) continue; for (int j = 0; j &lt; adj[u].size(); j++) &#123; int v = adj[u][j].first; if (color[v] == BLACK) continue; if (d[v] &gt; d[u] + adj[u][j].second) &#123; d[v] = d[u] + adj[u][j].second; PQ.push(make_pair(d[v] * (-1), v)); color[v] = GRAY; &#125; &#125; &#125; for (int i = 0; i &lt; n; i++) &#123; cout &lt;&lt; i &lt;&lt; &quot; &quot; &lt;&lt; (d[i] == INFTY ? -1 : d[i]) &lt;&lt; endl; &#125;&#125;int main()&#123; int k, u, v, c; cin &gt;&gt; n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; u &gt;&gt; k; for (int j = 0; j &lt; k; j++) &#123; cin &gt;&gt; v &gt;&gt; c; adj[u].push_back(make_pair(v, c)); &#125; &#125; dijkstra(); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1029 旧键盘（C++实现）","slug":"PAT-Basic-Level-1029-旧键盘（C++实现）","date":"2021-09-22T07:45:05.000Z","updated":"2021-09-22T07:04:16.075Z","comments":true,"path":"c9b85ffb/","link":"","permalink":"https://blog.ccuwxy.cn/c9b85ffb/","excerpt":"","text":"旧键盘上坏了几个键，于是在敲一段文字的时候，对应的字符就不会出现。现在给出应该输入的一段文字、以及实际被输入的文字，请你列出肯定坏掉的那些键。 输入格式：输入在 2 行中分别给出应该输入的文字、以及实际被输入的文字。每段文字是不超过 80 个字符的串，由字母 A-Z（包括大、小写）、数字 0-9、以及下划线 _（代表空格）组成。题目保证 2 个字符串均非空。 输出格式：按照发现顺序，在一行中输出坏掉的键。其中英文字母只输出大写，每个坏键只输出一次。题目保证至少有 1 个坏键。 输入样例：127_This_is_a_test_hs_s_a_es 输出样例：17TI 思路时间为200ms，统计实际输入的字符串的每个字符的ASCII的个数，遍历应该输入的字符串，对应ASCII为0，就是坏掉的键，输出坏掉的键后将值置-1，避免重复输出。 AC代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string a, b; char count[200] = &#123; 0 &#125;; cin &gt;&gt; a &gt;&gt; b; char ch; for (int i = 0; i &lt; b.length(); i++) &#123; ch = b.at(i); if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) ch -= 32; count[ch]++; &#125; for (int i = 0; i &lt; a.length(); i++) &#123; ch = a.at(i); if (ch &gt;= &#x27;a&#x27; &amp;&amp; ch &lt;= &#x27;z&#x27;) ch -= 32; if (count[ch] == 0) &#123; printf(&quot;%c&quot;, ch); count[ch] = -1; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1028 人口普查（C++实现）","slug":"PAT-Basic-Level-1028-人口普查（C++实现）","date":"2021-09-22T05:45:05.000Z","updated":"2021-09-22T07:04:16.075Z","comments":true,"path":"bd592838/","link":"","permalink":"https://blog.ccuwxy.cn/bd592838/","excerpt":"","text":"某城镇进行人口普查，得到了全体居民的生日。现请你写个程序，找出镇上最年长和最年轻的人。 这里确保每个输入的日期都是合法的，但不一定是合理的——假设已知镇上没有超过 200 岁的老人，而今天是 2014 年 9 月 6 日，所以超过 200 岁的生日和未出生的生日都是不合理的，应该被过滤掉。 输入格式：输入在第一行给出正整数 N，取值在(0,105]；随后 N 行，每行给出 1 个人的姓名（由不超过 5 个英文字母组成的字符串）、以及按 yyyy/mm/dd（即年/月/日）格式给出的生日。题目保证最年长和最年轻的人没有并列。 输出格式：在一行中顺序输出有效生日的个数、最年长人和最年轻人的姓名，其间以空格分隔。 输入样例：1234565John 2001&#x2F;05&#x2F;12Tom 1814&#x2F;09&#x2F;06Ann 2121&#x2F;01&#x2F;30James 1814&#x2F;09&#x2F;05Steve 1967&#x2F;11&#x2F;20 输出样例：13 Tom John 思路统计0-200岁的人数设置变量存储最年长的和最年轻的 注意一定不要给最年长的和最年轻的赋初值（初值可能不合理的）！！没有合理的日期，只输出0。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586#include&lt;iostream&gt;using namespace std;struct Person&#123; char name[6]; int year; int month; int day;&#125;;int main()&#123; int n; scanf(&quot;%d&quot;, &amp;n); Person *persons = new Person[n]; char name[6]; int year, month, day; int old, young;// 注意一定不要给最年长的和最年轻的赋初值 int count = 0; for (int i = 0; i &lt; n; i++) &#123; scanf(&quot;%s %d/%d/%d&quot;, persons[i].name, &amp;year, &amp;month, &amp;day); if (year &gt; 2014 || year &lt; 1814) continue; if (year == 2014) &#123; if (month &gt; 9) continue; else if(month == 9) &#123; if (day &gt; 6) continue; &#125; &#125; if (year == 1814) &#123; if (month &lt; 9) continue; else if (month == 9) if (day &lt; 6) continue; &#125; if (count &gt; 0) &#123; if (persons[old].year &gt; year) old = i; else if (persons[old].year == year) &#123; if (persons[old].month &gt; month) old = i; else if (persons[old].month == month) if (persons[old].day &gt; day) old = i; &#125; if (persons[young].year &lt; year) young = i; else if (persons[young].year == year) &#123; if (persons[young].month &lt; month) young = i; else if (persons[young].month == month) if (persons[young].day &lt; day) young = i; &#125; &#125; persons[i].year = year; persons[i].month = month; persons[i].day = day; if (!count) &#123; old = i; young = i; &#125; count++; &#125; if (count == 0) printf(&quot;0&quot;); else printf(&quot;%d %s %s&quot;, count, persons[old].name, persons[young].name); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1027 打印沙漏（C++实现）","slug":"PAT-Basic-Level-1027-打印沙漏（C++实现）","date":"2021-09-21T07:45:05.000Z","updated":"2021-09-22T07:04:16.074Z","comments":true,"path":"665f0810/","link":"","permalink":"https://blog.ccuwxy.cn/665f0810/","excerpt":"","text":"本题要求你写个程序把给定的符号打印成沙漏的形状。例如给定17个“*”，要求按下列格式打印 12345***** *** * ******** 所谓“沙漏形状”，是指每行输出奇数个符号；各行符号中心对齐；相邻两行符号数差2；符号数先从大到小顺序递减到1，再从小到大顺序递增；首尾符号数相等。 给定任意N个符号，不一定能正好组成一个沙漏。要求打印出的沙漏能用掉尽可能多的符号。 输入格式:输入在一行给出1个正整数N（≤1000）和一个符号，中间以空格分隔。 输出格式:首先打印出由给定符号组成的最大的沙漏形状，最后在一行中输出剩下没用掉的符号数。 输入样例:119 * 输出样例:123456***** *** * ********2 思路先计算需要打印几行，然后再确定每行打印几个。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int sum = -1; int i = -1; int count = 0; char c; cin &gt;&gt; c; while (sum&lt; n) &#123; i += 2; count++; sum += 2 * i; &#125; if (sum &gt; n) &#123; sum -= 2 * i; count--; &#125; for (int j = 2 * count - 1; j &gt; 0; j -= 2) &#123; for (int k = 0; k &lt; (2 * count - 1 - j) / 2; k++) printf(&quot; &quot;); for (int k = 0; k &lt; j; k++) printf(&quot;%c&quot;, c); printf(&quot;\\n&quot;); &#125; for (int j = 3; j &lt;= 2 * count - 1; j += 2) &#123; for (int k = 0; k &lt; (2 * count - 1 - j) / 2; k++) printf(&quot; &quot;); for (int k = 0; k &lt; j; k++) printf(&quot;%c&quot;, c); printf(&quot;\\n&quot;); &#125; cout &lt;&lt; n - sum; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1026 程序运行时间（C++实现）","slug":"PAT-Basic-Level-1026-程序运行时间（C++实现）","date":"2021-09-21T03:45:05.000Z","updated":"2021-09-22T07:04:16.074Z","comments":true,"path":"778fee68/","link":"","permalink":"https://blog.ccuwxy.cn/778fee68/","excerpt":"","text":"要获得一个 C 语言程序的运行时间，常用的方法是调用头文件 time.h，其中提供了 clock() 函数，可以捕捉从程序开始运行到 clock() 被调用时所耗费的时间。这个时间单位是 clock tick，即“时钟打点”。同时还有一个常数 CLK_TCK，给出了机器时钟每秒所走的时钟打点数。于是为了获得一个函数 f 的运行时间，我们只要在调用 f 之前先调用 clock()，获得一个时钟打点数 C1；在 f 执行完成后再调用 clock()，获得另一个时钟打点数 C2；两次获得的时钟打点数之差 (C2-C1) 就是 f 运行所消耗的时钟打点数，再除以常数 CLK_TCK，就得到了以秒为单位的运行时间。 这里不妨简单假设常数 CLK_TCK 为 100。现给定被测函数前后两次获得的时钟打点数，请你给出被测函数运行的时间。 输入格式：输入在一行中顺序给出 2 个整数 C1 和 C2。注意两次获得的时钟打点数肯定不相同，即 C1 &lt; C2，并且取值在 [0,107]。 输出格式：在一行中输出被测函数运行的时间。运行时间必须按照 hh:mm:ss（即2位的 时:分:秒）格式输出；不足 1 秒的时间四舍五入到秒。 输入样例：1123 4577973 输出样例：112:42:59 思路不足 1 秒的时间四舍五入到秒，可以通过加0.5秒实现。 AC代码12345678910111213#include&lt;iostream&gt;using namespace std;int main()&#123; int c1, c2; scanf(&quot;%d %d&quot;, &amp;c1, &amp;c2); int ans = c2 - c1 + 50; int hour = ans / 360000, minues = ans % 360000 / 6000; int sec = ans % 6000 / 100; printf(&quot;%02d:%02d:%02d&quot;, hour, minues, sec); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1025 反转链表（C++实现）","slug":"PAT-Basic-Level-1025-反转链表（C++实现）","date":"2021-09-20T07:45:05.000Z","updated":"2021-09-22T07:04:16.073Z","comments":true,"path":"ef4192d4/","link":"","permalink":"https://blog.ccuwxy.cn/ef4192d4/","excerpt":"","text":"给定一个常数 K 以及一个单链表 L，请编写程序将 L 中每 K 个结点反转。例如：给定 L 为 1→2→3→4→5→6，K 为 3，则输出应该为 3→2→1→6→5→4；如果 K 为 4，则输出应该为 4→3→2→1→5→6，即最后不到 K 个元素不反转。 输入格式：每个输入包含 1 个测试用例。每个测试用例第 1 行给出第 1 个结点的地址、结点总个数正整数 N (≤105)、以及正整数 K (≤N)，即要求反转的子链结点的个数。结点的地址是 5 位非负整数，NULL 地址用 −1 表示。 接下来有 N 行，每行格式为： 1Address Data Next 其中 Address 是结点地址，Data 是该结点保存的整数数据，Next 是下一结点的地址。 输出格式：对每个测试用例，顺序输出反转后的链表，其上每个结点占一行，格式与输入相同。 输入样例：123456700100 6 400000 4 9999900100 1 1230968237 6 -133218 3 0000099999 5 6823712309 2 33218 输出样例：12345600000 4 3321833218 3 1230912309 2 0010000100 1 9999999999 5 6823768237 6 -1 AC代码12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;algorithm&gt;using namespace std;int main() &#123; int first, k, n, temp; cin &gt;&gt; first &gt;&gt; n &gt;&gt; k; int* data = new int[100005]; int* next = new int[100005]; int* list = new int[100005]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; temp; cin &gt;&gt; data[temp] &gt;&gt; next[temp]; &#125; int sum = 0; while (first != -1) &#123; list[sum++] = first; first = next[first]; &#125; for (int i = 0; i &lt; (sum - sum % k); i += k) reverse(list + i, list + i + k); for (int i = 0; i &lt; sum - 1; i++) printf(&quot;%05d %d %05d\\n&quot;, list[i], data[list[i]], list[i + 1]); printf(&quot;%05d %d -1&quot;, list[sum - 1], data[list[sum - 1]]); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1024 科学计数法（C++实现）","slug":"PAT-Basic-Level-1024-科学计数法（C++实现）","date":"2021-09-17T07:45:05.000Z","updated":"2021-09-17T07:39:26.172Z","comments":true,"path":"15bdd54f/","link":"","permalink":"https://blog.ccuwxy.cn/15bdd54f/","excerpt":"","text":"科学计数法是科学家用来表示很大或很小的数字的一种方便的方法，其满足正则表达式 [+-][1-9].[0-9]+E[+-][0-9]+，即数字的整数部分只有 1 位，小数部分至少有 1 位，该数字及其指数部分的正负号即使对正数也必定明确给出。 现以科学计数法的格式给出实数 A，请编写程序按普通数字表示法输出 A，并保证所有有效位都被保留。 输入格式：每个输入包含 1 个测试用例，即一个以科学计数法表示的实数 A。该数字的存储长度不超过 9999 字节，且其指数的绝对值不超过 9999。 输出格式：对每个测试用例，在一行中按普通数字表示法输出 A，并保证所有有效位都被保留，包括末尾的 0。 输入样例 1：1+1.23400E-03 输出样例 1：10.00123400 输入样例 2：1-1.2E+10 输出样例 2：1-12000000000 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; string a; char sign1, sign2; cin &gt;&gt; a; sign1 = a.at(0); a.erase(0,1); int pos_E = a.find_first_of(&#x27;E&#x27;); sign2 = a.at(pos_E + 1); int index = 0; int j = 0; for (int i = a.length()-1; i &gt; pos_E+1; i--) &#123; index += (int)((a.at(i) - &#x27;0&#x27;) * pow(10, j++)); &#125; a.erase(pos_E); if (sign2 == &#x27;+&#x27;) &#123; int behind_dot = a.length() - 2; if (index &gt;= behind_dot) &#123; for (int i = 0; i &lt; index - behind_dot; i++) a.push_back(&#x27;0&#x27;); a.erase(1, 1); &#125; else &#123; a.erase(1, 1); a.insert(1+index,&quot;.&quot;,1); &#125; &#125; else if (sign2 == &#x27;-&#x27;) &#123; a.erase(1, 1); for (int i = 0; i &lt; index; i++) &#123; a.insert(0, &quot;0&quot;, 1); &#125; a.insert(1, &quot;.&quot;, 1); &#125; if (sign1 == &#x27;-&#x27;) &#123; cout &lt;&lt; sign1 &lt;&lt; a; &#125; else &#123; cout &lt;&lt; a; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1023 组个最小数（C++实现）","slug":"PAT-Basic-Level-1023-组个最小数（C++实现）","date":"2021-09-17T07:30:05.000Z","updated":"2021-09-17T07:39:26.172Z","comments":true,"path":"dbc8a747/","link":"","permalink":"https://blog.ccuwxy.cn/dbc8a747/","excerpt":"","text":"给定数字 0-9 各若干个。你可以以任意顺序排列这些数字，但必须全部使用。目标是使得最后得到的数尽可能小（注意 0 不能做首位）。例如：给定两个 0，两个 1，三个 5，一个 8，我们得到的最小的数就是 10015558。 现给定数字，请编写程序输出能够组成的最小的数。 输入格式：输入在一行中给出 10 个非负整数，顺序表示我们拥有数字 0、数字 1、……数字 9 的个数。整数间用一个空格分隔。10 个数字的总个数不超过 50，且至少拥有 1 个非 0 的数字。 输出格式：在一行中输出能够组成的最小的数。 输入样例：12 2 0 0 0 3 0 0 1 0 输出样例：110015558 思路新建一个数组，数组中的值是数组索引值出现的次数，从1-9 找到第一个个数不为0的索引值，当做数字的首位，然后从0遍历9，输出数组中值个数的索引值。 AC代码1234567891011121314151617181920212223#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a[10]; for (int i = 0; i &lt; 10; i++) cin &gt;&gt; a[i]; int j = 1; while (a[j] == 0) &#123; j++; &#125; printf(&quot;%d&quot;, j); a[j]--; for (int i = 0; i &lt; 10; i++) &#123; for (int j = 0; j &lt; a[i]; j++) printf(&quot;%d&quot;, i); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1022 D进制的A+B（C++实现）","slug":"PAT-Basic-Level-1022-D进制的A+B（C++实现）","date":"2021-09-17T07:20:05.000Z","updated":"2021-09-17T07:39:26.171Z","comments":true,"path":"6519c1ab/","link":"","permalink":"https://blog.ccuwxy.cn/6519c1ab/","excerpt":"","text":"输入两个非负 10 进制整数 A 和 B (≤230−1)，输出 A+B 的 D (1&lt;D≤10)进制数。 输入格式：输入在一行中依次给出 3 个整数 A、B 和 D。 输出格式：输出 A+B 的 D 进制数。 输入样例：1123 456 8 输出样例：11103 思路d进制数，数字相加后，循环进行 对d求余、对d相除，并将求余结果存入数组中，最后逆序输出结果。 AC代码12345678910111213141516171819202122232425#include&lt;iostream&gt;#include&lt;string&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int a, b, d; cin &gt;&gt; a &gt;&gt; b &gt;&gt; d; int num = a + b; if (num == 0) &#123; cout &lt;&lt; 0; return 0; &#125; string ans; while (num) &#123; ans.push_back(num % d+&#x27;0&#x27;); num /= d; &#125; reverse(ans.begin(), ans.end()); cout &lt;&lt; ans; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1021 个位数统计（C++实现）","slug":"PAT-Basic-Level-1021-个位数统计（C++实现）","date":"2021-09-17T06:20:05.000Z","updated":"2021-09-17T07:39:26.171Z","comments":true,"path":"2db3f179/","link":"","permalink":"https://blog.ccuwxy.cn/2db3f179/","excerpt":"","text":"给定一个 k 位整数 N=d**k−110k−1+⋯+d1101+d0 (0≤d**i≤9, i=0,⋯,k−1, d**k−1&gt;0)，请编写程序统计每种不同的个位数字出现的次数。例如：给定 N=100311，则有 2 个 0，3 个 1，和 1 个 3。 输入格式：每个输入包含 1 个测试用例，即一个不超过 1000 位的正整数 N。 输出格式：对 N 中每一种不同的个位数字，以 D:M 的格式在一行中输出该位数字 D 及其在 N 中出现的次数 M。要求按 D 的升序输出。 输入样例：1100311 输出样例：1230:21:33:1 思路建立一个数组，索引下标为0-9，数组的值为对应数字的个数；最后遍历数组，如果值大于0，就输出索引值。 AC代码1234567891011121314151617181920212223242526272829#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int a[10] = &#123; 0 &#125;; char num[1001] = &#123;&#x27;\\0&#x27;&#125;; scanf(&quot;%s&quot;, num); for (int i = 0; num[i]!=&#x27;\\0&#x27;; i++) &#123; a[num[i] - &#x27;0&#x27;]++; &#125; bool b = false; for (int i = 0; i &lt; 10; i++) &#123; if (a[i] &gt; 0) &#123; if (b) printf(&quot;\\n&quot;); printf(&quot;%d:%d&quot;, i, a[i]); b = true; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1020 月饼（C++实现）","slug":"PAT-Basic-Level-1020-月饼（C++实现）","date":"2021-09-14T09:20:05.000Z","updated":"2021-09-17T07:39:26.170Z","comments":true,"path":"af8c75be/","link":"","permalink":"https://blog.ccuwxy.cn/af8c75be/","excerpt":"","text":"月饼是中国人在中秋佳节时吃的一种传统食品，不同地区有许多不同风味的月饼。现给定所有种类月饼的库存量、总售价、以及市场的最大需求量，请你计算可以获得的最大收益是多少。 注意：销售时允许取出一部分库存。样例给出的情形是这样的：假如我们有 3 种月饼，其库存量分别为 18、15、10 万吨，总售价分别为 75、72、45 亿元。如果市场的最大需求量只有 20 万吨，那么我们最大收益策略应该是卖出全部 15 万吨第 2 种月饼、以及 5 万吨第 3 种月饼，获得 72 + 45/2 = 94.5（亿元）。 输入格式：每个输入包含一个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N 表示月饼的种类数、以及不超过 500（以万吨为单位）的正整数 D 表示市场最大需求量。随后一行给出 N 个正数表示每种月饼的库存量（以万吨为单位）；最后一行给出 N 个正数表示每种月饼的总售价（以亿元为单位）。数字间以空格分隔。 输出格式：对每组测试用例，在一行中输出最大收益，以亿元为单位并精确到小数点后 2 位。 输入样例：1233 2018 15 1075 72 45 输出样例：194.50 思路先将月饼单价按照高到低排序，然后从价格高月饼的开始统计收益，最高的数量不足需求量，再计算次高的……坑：N、D为正整数，月饼的库存量为正数，最后输出精确到小数点后 2 位 AC代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct moon&#123; float total;//正数 float avg;&#125;;bool cmp(moon a, moon b)&#123; return a.avg &gt; b.avg;&#125;int main()&#123; int N, D; cin &gt;&gt; N &gt;&gt; D; moon *moons = new moon[N]; float money; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; moons[i].total; &#125; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; money; moons[i].avg = money / moons[i].total; &#125; sort(moons, moons + N,cmp); float maxMoney = 0; for (int i = 0; i &lt; N &amp;&amp; D&gt;0; i++) &#123; if (moons[i].total &lt; D) &#123; maxMoney += moons[i].total * moons[i].avg; D -= moons[i].total; &#125; else &#123; maxMoney += D * moons[i].avg; D -= D; &#125; &#125; printf(&quot;%.2f&quot;, maxMoney); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1017 A除以B（C++实现）","slug":"PAT-Basic-Level-1017-A除以B（C++实现）","date":"2021-09-07T11:50:05.000Z","updated":"2021-09-07T11:52:25.413Z","comments":true,"path":"c1cf90aa/","link":"","permalink":"https://blog.ccuwxy.cn/c1cf90aa/","excerpt":"","text":"本题要求计算 A/B，其中 A 是不超过 1000 位的正整数，B 是 1 位正整数。你需要输出商数 Q 和余数 R，使得 A=B×Q+R 成立。 输入格式：输入在一行中依次给出 A 和 B，中间以 1 空格分隔。 输出格式：在一行中依次输出 Q 和 R，中间以 1 空格分隔。 输入样例：1123456789050987654321 7 输出样例：117636684150141093474 3 思路1000位整数需要存放在数组中，模仿手算除法，很简单需要特殊处理商的首位0 AC代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;using namespace std;int main()&#123; char a[1001]; char q[1001]; int b; scanf(&quot;%s %d&quot;, a, &amp;b); int before = 0; int curr; int j = 0; for (int i = 0; a[i] != &#x27;\\0&#x27;; i++) &#123; curr = a[i] - &#x27;0&#x27; + 10 * before; if (curr / b == 0) &#123; if(i!=0) q[j++] = &#x27;0&#x27;; before = curr; continue; &#125; q[j++] = curr / b +&#x27;0&#x27;; before = curr % b; &#125; if (j == 0) q[j++] = &#x27;0&#x27;; q[j] = &#x27;\\0&#x27;; cout &lt;&lt; q &lt;&lt; &quot; &quot; &lt;&lt; before; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1016 部分A+B（C++实现）","slug":"PAT-Basic-Level-1016-部分A+B（C++实现）","date":"2021-09-07T11:30:05.000Z","updated":"2021-09-07T11:52:25.403Z","comments":true,"path":"fc81fd81/","link":"","permalink":"https://blog.ccuwxy.cn/fc81fd81/","excerpt":"","text":"正整数 A 的“DA（为 1 位整数）部分”定义为由 A 中所有 DA 组成的新整数 PA。例如：给定 A=3862767，DA=6，则 A 的“6 部分”PA 是 66，因为 A 中有 2 个 6。 现给定 A、DA、B、DB，请编写程序计算 PA+PB。 输入格式：输入在一行中依次给出 A、DA、B、DB，中间以空格分隔，其中 0&lt;A,B&lt;109。 输出格式：在一行中输出 PA+PB 的值。 输入样例 1：13862767 6 13530293 3 输出样例 1：1399 输入样例 2：13862767 1 13530293 8 输出样例 2：10 思路AC代码123456789101112131415161718192021222324252627282930313233#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int a, b; int da, db; cin &gt;&gt; a &gt;&gt; da; cin &gt;&gt; b &gt;&gt; db; int pa = 0, pb = 0; int i = 0, j = 0; while (a) &#123; if (a % 10 == da) &#123; pa += da*pow(10,i++); &#125; a /= 10; &#125; while (b) &#123; if (b % 10 == db) &#123; pb += db*pow(10,j++); &#125; b /= 10; &#125; cout &lt;&lt; pa + pb; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1015 德才论（C++实现）","slug":"PAT-Basic-Level-1015-德才论（C++实现）","date":"2021-09-06T06:32:05.000Z","updated":"2021-09-06T06:27:42.686Z","comments":true,"path":"59bbe03f/","link":"","permalink":"https://blog.ccuwxy.cn/59bbe03f/","excerpt":"","text":"宋代史学家司马光在《资治通鉴》中有一段著名的“德才论”：“是故才德全尽谓之圣人，才德兼亡谓之愚人，德胜才谓之君子，才胜德谓之小人。凡取人之术，苟不得圣人，君子而与之，与其得小人，不若得愚人。” 现给出一批考生的德才分数，请根据司马光的理论给出录取排名。 输入格式：输入第一行给出 3 个正整数，分别为：N（≤105），即考生总数；L（≥60），为录取最低分数线，即德分和才分均不低于 L 的考生才有资格被考虑录取；H（&lt;100），为优先录取线——德分和才分均不低于此线的被定义为“才德全尽”，此类考生按德才总分从高到低排序；才分不到但德分到线的一类考生属于“德胜才”，也按总分排序，但排在第一类考生之后；德才分均低于 H，但是德分不低于才分的考生属于“才德兼亡”但尚有“德胜才”者，按总分排序，但排在第二类考生之后；其他达到最低线 L 的考生也按总分排序，但排在第三类考生之后。 随后 N 行，每行给出一位考生的信息，包括：准考证号 德分 才分，其中准考证号为 8 位整数，德才分为区间 [0, 100] 内的整数。数字间以空格分隔。 输出格式：输出第一行首先给出达到最低分数线的考生人数 M，随后 M 行，每行按照输入格式输出一位考生的信息，考生按输入中说明的规则从高到低排序。当某类考生中有多人总分相同时，按其德分降序排列；若德分也并列，则按准考证号的升序输出。 输入样例：12345678910111213141514 60 8010000001 64 9010000002 90 6010000011 85 8010000003 85 8010000004 80 8510000005 82 7710000006 83 7610000007 90 7810000008 75 7910000009 59 9010000010 88 4510000012 80 10010000013 90 9910000014 66 60 输出样例：123456789101112131210000013 90 9910000012 80 10010000003 85 8010000011 85 8010000004 80 8510000007 90 7810000006 83 7610000005 82 7710000002 90 6010000014 66 6010000008 75 7910000001 64 90 思路把学号、德分、才分、德才总分和类别都存到结构体中，然后排序。类别从小到大，总分从大到小，德分从大到小，学号从小到大。 AC代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct student&#123; int no; int de; int cai; int sum; int clas;&#125;;bool cmp(student s1, student s2)&#123; if (s1.clas != s2.clas) return s1.clas &lt; s2.clas; else if (s1.sum != s2.sum) return s1.sum &gt; s2.sum; else if (s1.de != s2.de) return s1.de &gt; s2.de; else return s1.no &lt; s2.no;&#125;int main()&#123; int n, l, h; cin &gt;&gt; n &gt;&gt; l &gt;&gt; h; student *stu = new student[n]; int count = n; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stu[i].no &gt;&gt; stu[i].de &gt;&gt; stu[i].cai; stu[i].sum = stu[i].de + stu[i].cai; if (stu[i].de &lt; l || stu[i].cai &lt; l) &#123; stu[i].clas = 5; count--; &#125; else if (stu[i].de &gt;= h &amp;&amp; stu[i].cai &gt;= h) stu[i].clas = 1; else if (stu[i].cai &lt; h &amp;&amp; stu[i].de &gt;= h) stu[i].clas = 2; else if (stu[i].de &gt;= stu[i].cai) stu[i].clas = 3; else stu[i].clas = 4; &#125; sort(stu, stu + n, cmp); cout &lt;&lt; count &lt;&lt; endl; for (int i = 0; i &lt; count; i++) &#123; printf(&quot;%d %d %d&quot;, stu[i].no, stu[i].de, stu[i].cai); if (i != count - 1) printf(&quot;\\n&quot;); &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1014 福尔摩斯的约会（C++实现）","slug":"PAT-Basic-Level-1014-福尔摩斯的约会（C++实现）","date":"2021-09-06T02:32:05.000Z","updated":"2021-09-06T06:27:42.685Z","comments":true,"path":"e4d95360/","link":"","permalink":"https://blog.ccuwxy.cn/e4d95360/","excerpt":"","text":"大侦探福尔摩斯接到一张奇怪的字条：我们约会吧！ 3485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm。大侦探很快就明白了，字条上奇怪的乱码实际上就是约会的时间星期四 14:04，因为前面两字符串中第 1 对相同的大写英文字母（大小写有区分）是第 4 个字母 D，代表星期四；第 2 对相同的字符是 E ，那是第 5 个英文字母，代表一天里的第 14 个钟头（于是一天的 0 点到 23 点由数字 0 到 9、以及大写字母 A 到 N 表示）；后面两字符串第 1 对相同的英文字母 s 出现在第 4 个位置（从 0 开始计数）上，代表第 4 分钟。现给定两对字符串，请帮助福尔摩斯解码得到约会的时间。 输入格式：输入在 4 行中分别给出 4 个非空、不包含空格、且长度不超过 60 的字符串。 输出格式：在一行中输出约会的时间，格式为 DAY HH:MM，其中 DAY 是某星期的 3 字符缩写，即 MON 表示星期一，TUE 表示星期二，WED 表示星期三，THU 表示星期四，FRI 表示星期五，SAT 表示星期六，SUN 表示星期日。题目输入保证每个测试存在唯一解。 输入样例：12343485djDkxh4hhGE 2984akDfkkkkggEdsb s&amp;hgsfdk d&amp;Hyscvnm 输出样例：1THU 14:04 思路第 1 对相同的大写英文字母：A-G（MON-SUN）；第 2 对相同的字符：0-9、A-N；后面两字符串第 1 对相同的英文字母：索引从0开始；小时和分钟是一位的前面需要补0。 AC 代码1234567891011121314151617181920212223242526272829303132333435363738394041424344#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; string s1, s2, s3, s4; cin &gt;&gt; s1 &gt;&gt; s2 &gt;&gt; s3 &gt;&gt; s4; int week = 0, hour = -1, minus = -1; int flag = 0; int temp; for (int i = 0; i &lt; s1.size() &amp;&amp; i &lt; s2.size(); i++) &#123; temp = s1.at(i); if (temp == s2.at(i)) &#123; if (flag == 0) &#123; if (temp &gt; &#x27;G&#x27; || temp &lt; &#x27;A&#x27;) continue; week = temp - &#x27;A&#x27; + 1; flag++; &#125; else if (temp &gt;= &#x27;0&#x27; &amp;&amp; temp &lt;= &#x27;9&#x27; || temp &gt;= &#x27;A&#x27; &amp;&amp; temp &lt;= &#x27;N&#x27;) &#123; hour = temp &gt;= &#x27;A&#x27; ? (temp - &#x27;A&#x27; + 10) : (temp - &#x27;0&#x27;); break; &#125; &#125; &#125; for (int i = 0; i &lt; s3.size() &amp;&amp; i &lt; s4.size(); i++) &#123; temp = s3.at(i); if (temp &lt; &#x27;A&#x27; || (temp &gt; &#x27;Z&#x27; &amp;&amp; temp &lt; &#x27;a&#x27;) || temp &gt;&#x27;z&#x27;) continue; if (temp == s4.at(i)) &#123; minus = i; &#125; &#125; string week_str[] = &#123; &quot;&quot;,&quot;MON&quot;,&quot;TUE&quot;,&quot;WED&quot;,&quot;THU&quot;,&quot;FRI&quot;,&quot;SAT&quot;,&quot;SUN&quot; &#125;; cout &lt;&lt; week_str[week] &lt;&lt; &quot; &quot;; printf(&quot;%02d:%02d&quot;, hour, minus); return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1012 数字分类（C++实现）","slug":"PAT-Basic-Level-1012-数字分类（C++实现）","date":"2021-09-01T09:00:02.000Z","updated":"2021-09-01T09:16:25.233Z","comments":true,"path":"f73146d3/","link":"","permalink":"https://blog.ccuwxy.cn/f73146d3/","excerpt":"","text":"给定一系列正整数，请按要求对数字进行分类，并输出以下 5 个数字： A1 = 能被 5 整除的数字中所有偶数的和； A2 = 将被 5 除后余 1 的数字按给出顺序进行交错求和，即计算 n1−n2+n3−n4⋯； A3 = 被 5 除后余 2 的数字的个数； A4 = 被 5 除后余 3 的数字的平均数，精确到小数点后 1 位； A5 = 被 5 除后余 4 的数字中最大数字。 输入格式：每个输入包含 1 个测试用例。每个测试用例先给出一个不超过 1000 的正整数 N，随后给出 N 个不超过 1000 的待分类的正整数。数字间以空格分隔。 输出格式：对给定的 N 个正整数，按题目要求计算 A1~A5 并在一行中顺序输出。数字间以空格分隔，但行末不得有多余空格。 若其中某一类数字不存在，则在相应位置输出 N。 输入样例 1：1213 1 2 3 4 5 6 7 8 9 10 20 16 18 输出样例 1：130 11 2 9.7 9 输入样例 2：18 1 2 4 5 6 7 9 16 输出样例 2：1N 11 2 N 9 AC代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include&lt;iostream&gt;#include &lt;iomanip&gt; using namespace std;int main()&#123; int N; int A1 = 0, A2 = 0, A3 = 0, A5 = 0; float A4 = 0; int count1 = 0, count2 = 0, count3 = 0, count4 = 0, count5 = 0; float sum4 = 0.0; cin &gt;&gt; N; int temp; int flag = 1; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; temp; if (temp % 5 == 0 &amp;&amp; temp % 2 == 0) &#123; count1++; A1 += temp; &#125; if (temp % 5 == 1) &#123; count2++; A2 += flag * temp; flag *= -1; &#125; if (temp % 5 == 2) &#123; count3++; A3++; &#125; if (temp % 5 == 3) &#123; count4++; sum4 += temp; &#125; if (temp % 5 == 4) &#123; count5++; A5 = A5 &gt; temp ? A5 : temp; &#125; &#125; A4 = (float)sum4 / count4; if (count1) cout &lt;&lt; A1 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count2) cout &lt;&lt; A2 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count3) cout &lt;&lt; A3 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count4) //printf(&quot;%0.1f &quot;, A4); cout &lt;&lt; setiosflags(ios::fixed) &lt;&lt; setprecision(1) &lt;&lt; A4 &lt;&lt; &quot; &quot;; else cout &lt;&lt; &quot;N &quot;; if (count5) cout &lt;&lt; A5; else cout &lt;&lt; &quot;N&quot;; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1013 数素数（C++实现）","slug":"PAT-Basic-Level-1013-数素数（C++实现）","date":"2021-09-01T08:30:05.000Z","updated":"2021-09-01T09:03:37.512Z","comments":true,"path":"8ce3536b/","link":"","permalink":"https://blog.ccuwxy.cn/8ce3536b/","excerpt":"","text":"令 Pi 表示第 i 个素数。现任给两个正整数 M≤N≤10000，请输出 PM 到 PN 的所有素数。 输入格式：输入在一行中给出 M 和 N，其间以空格分隔。 输出格式：输出从PM 到 PN 的所有素数，每 10 个数字占 1 行，其间以空格分隔，但行末不得有多余空格。 输入样例：15 27 输出样例：12311 13 17 19 23 29 31 37 41 4347 53 59 61 67 71 73 79 83 8997 101 103 AC代码：素数：2 3 5 7 11 13 ……思路：每个数与除了1以外的整数相除，最大除数为√数，如果有能够整除的，就不是素数，反之为素数。设置一个数统计当前是第几个素数，当可以与10整除的时候输出换行，反之输出空格。 12345678910111213141516171819202122232425262728293031323334353637#include&lt;iostream&gt;#include&lt;cmath&gt;using namespace std;int main()&#123; int m, n; cin &gt;&gt; m &gt;&gt; n; int count = 0; int flag = 1; int c = 0; for (int i = 2; count &lt; n; i++) &#123; for (int j = 2; j &lt;= sqrt(i); j++) &#123; flag = 1; if (i % j == 0) &#123; flag = 0; break; &#125; &#125; if (flag) &#123; if (++count &gt;= m) &#123; cout &lt;&lt; i; if (++c % 10 == 0) cout &lt;&lt; endl; else if(count &lt; n) cout &lt;&lt; &quot; &quot;; &#125; &#125; &#125; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1071 小赌怡情（C++实现）","slug":"PAT-Basic-Level-1071-小赌怡情（C++实现）","date":"2021-03-07T03:20:05.000Z","updated":"2021-03-07T06:08:30.936Z","comments":true,"path":"6b819853/","link":"","permalink":"https://blog.ccuwxy.cn/6b819853/","excerpt":"","text":"常言道“小赌怡情”。这是一个很简单的小游戏：首先由计算机给出第一个整数；然后玩家下注赌第二个整数将会比第一个数大还是小；玩家下注 t 个筹码后，计算机给出第二个数。若玩家猜对了，则系统奖励玩家 t 个筹码；否则扣除玩家 t 个筹码。 注意：玩家下注的筹码数不能超过自己帐户上拥有的筹码数。当玩家输光了全部筹码后，游戏就结束。 输入格式：输入在第一行给出 2 个正整数 T 和 K（≤ 100），分别是系统在初始状态下赠送给玩家的筹码数、以及需要处理的游戏次数。随后 K 行，每行对应一次游戏，顺序给出 4 个数字： 1n1 b t n2 其中 n1 和 n2 是计算机先后给出的两个[0, 9]内的整数，保证两个数字不相等。b 为 0 表示玩家赌小，为 1 表示玩家赌大。t 表示玩家下注的筹码数，保证在整型范围内。 输出格式：对每一次游戏，根据下列情况对应输出（其中t是玩家下注量，x 是玩家当前持有的筹码量）： 玩家赢，输出 Win t! Total = x.；玩家输，输出 Lose t. Total = x.；玩家下注超过持有的筹码量，输出 Not enough tokens. Total = x.；玩家输光后，输出 Game Over. 并结束程序。 输入样例 1：12345100 48 0 100 23 1 50 15 1 200 67 0 200 8 输出样例 1：1234Win 100! Total = 200.Lose 50. Total = 150.Not enough tokens. Total = 150.Not enough tokens. Total = 150. 输入样例 2：12345100 48 0 100 23 1 200 15 1 200 67 0 200 8 输出样例 2：123Win 100! Total = 200.Lose 200. Total = 0.Game Over. AC代码(C++)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include&lt;iostream&gt;using namespace std;int main()&#123; int T, K; cin &gt;&gt; T &gt;&gt; K; for (int i = 0; i &lt; K; i++) &#123; if (T == 0) &#123; cout &lt;&lt; &quot;Game Over.&quot;; break; &#125; int n1, b, t, n2; cin &gt;&gt; n1 &gt;&gt; b &gt;&gt; t &gt;&gt; n2; if (t &gt; T) cout &lt;&lt; &quot;Not enough tokens. Total = &quot; &lt;&lt; T &lt;&lt;&quot;.&quot; &lt;&lt; endl; else &#123; if (b == 1) &#123; if (n2 &gt; n1) &#123; T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; else &#123; T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; &#125; else if (b == 0) &#123; if (n2 &lt; n1) &#123; T += t; cout &lt;&lt; &quot;Win &quot; &lt;&lt; t &lt;&lt; &quot;! Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; else &#123; T -= t; cout &lt;&lt; &quot;Lose &quot; &lt;&lt; t &lt;&lt; &quot;. Total = &quot; &lt;&lt; T &lt;&lt; &quot;.&quot; &lt;&lt; endl; &#125; &#125; &#125; &#125; return 0;&#125; AC代码（Java）12345678910111213141516171819202122232425262728293031323334353637383940414243444546import java.util.Scanner;public class T1071 &#123; public static void main(String[] args) &#123; int T,K; Scanner sc = new Scanner(System.in); T = sc.nextInt(); K = sc.nextInt(); for(int i = 0; i &lt; K;i++)&#123; if(T==0) &#123; System.out.print(&quot;Game Over.&quot;); break; &#125; int n1,b,t,n2; n1 = sc.nextInt(); b = sc.nextInt(); t = sc.nextInt(); n2 = sc.nextInt(); if(t &gt; T) System.out.println(&quot;Not enough tokens. Total = &quot;+T+&quot;.&quot;); else&#123; if(b==1)&#123; if(n2&gt;n1)&#123; T+=t; System.out.println(&quot;Win &quot;+t+&quot;! Total = &quot;+T+&quot;.&quot;); &#125;else&#123; T-=t; System.out.println(&quot;Lose &quot;+t+&quot;. Total = &quot;+T+&quot;.&quot;); &#125; &#125;else if(b==0)&#123; if(n2&lt;n1)&#123; T+=t; System.out.println(&quot;Win &quot;+t+&quot;! Total = &quot;+T+&quot;.&quot;); &#125;else&#123; T-=t; System.out.println(&quot;Lose &quot;+t+&quot;. Total = &quot;+T+&quot;.&quot;); &#125; &#125; &#125; &#125; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"选择法对数组中的整数按照从小到大排序","slug":"选择法对数组中的整数按照从小到大排序","date":"2021-03-06T03:00:05.000Z","updated":"2021-03-06T03:10:22.782Z","comments":true,"path":"9c73aafb/","link":"","permalink":"https://blog.ccuwxy.cn/9c73aafb/","excerpt":"","text":"思路首先将最小的数与a[0]对换；再将a[1]~a[n]中最小的数与a[1]对换……每比较一轮，找出一个最小的，共比较n-1轮。 代码1234567891011121314151617181920212223242526272829303132333435#include&lt;stdio.h&gt;int main()&#123; void sort(int array[], int n); int a[10]; for (int i = 0; i &lt; 10; i++) &#123; scanf(&quot;%d&quot;, &amp;a[i]); &#125; sort(a, 10); for (int i = 0; i &lt; 10; i++) &#123; printf(&quot;%d &quot;, a[i]); &#125; return 0;&#125;void sort(int array[], int n)&#123; int k, t; for (int i = 0; i &lt; n - 1; i++) &#123; k = i; for (int j = i + 1; j &lt; n; j++) &#123; if (array[j] &lt; array[k]) k = j; &#125; t = array[k]; array[k] = array[i]; array[i] = t; &#125;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1008 数组元素循环右移问题（C++实现）","slug":"PAT-Basic-Level-1008-数组元素循环右移问题（C++实现）","date":"2021-02-07T03:30:05.000Z","updated":"2021-02-07T03:38:59.690Z","comments":true,"path":"a786d318/","link":"","permalink":"https://blog.ccuwxy.cn/a786d318/","excerpt":"","text":"一个数组A中存有N（&gt;0）个整数，在不允许使用另外数组的前提下，将每个整数循环向右移M（≥0）个位置（最后M个数循环移至最前面的M个位置）。如果需要考虑程序移动数据的次数尽量少，要如何设计移动的方法？ 输入格式:每个输入包含一个测试用例，第1行输入N（1≤N≤100）和M（≥0）；第2行输入N个整数，之间用空格分隔。 输出格式:在一行中输出循环右移M位以后的整数序列，之间用空格分隔，序列结尾不能有多余空格。 输入样例:126 21 2 3 4 5 6 输出样例:15 6 1 2 3 4 AC代码思路：先全部逆置，然后前M个和后面N-M个分别逆置 123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int N, M; cin &gt;&gt; N &gt;&gt; M; int* nums = new int[N]; for (int i = 0; i &lt; N; i++) cin &gt;&gt; nums[i]; M = M % N; int temp; for (int i = 0; i &lt; N / 2; i++) &#123; temp = nums[i]; nums[i] = nums[N - 1 - i]; nums[N - 1 - i] = temp; &#125; for (int i = 0; i &lt; M/2; i++) &#123; temp = nums[i]; nums[i] = nums[M - 1 - i]; nums[M - 1 - i] = temp; &#125; for (int i = M; i &lt; (N-M)/2+M; i++) &#123; temp = nums[i]; nums[i] = nums[N - 1 - i + M]; nums[N - 1 - i + M] = temp; &#125; for (int i = 0; i &lt; N; i++) &#123; cout &lt;&lt; nums[i]; if (i != N - 1) cout &lt;&lt; &quot; &quot;; &#125; delete[] nums; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1007 素数对猜想（C++实现）","slug":"PAT-Basic-Level-1007-素数对猜想（C++实现）","date":"2021-02-07T03:20:05.000Z","updated":"2021-02-07T03:07:54.798Z","comments":true,"path":"c37c6e1d/","link":"","permalink":"https://blog.ccuwxy.cn/c37c6e1d/","excerpt":"","text":"“素数对猜想”认为“存在无穷多对相邻且差为2的素数”现给定任意正整数N(&lt;10^5)，请计算不超过N的满足猜想的素数对的个数。 输入格式:输入在一行给出正整数N。 输出格式:在一行中输出不超过N的满足猜想的素数对的个数。 输入样例:120 输出样例:14 AC代码1234567891011121314151617181920212223242526272829303132333435#include&lt;iostream&gt;#include&lt;math.h&gt;using namespace std;int main()&#123; int N, count = 0; int temp = 0; cin &gt;&gt; N; int* nums = new int[N+1]&#123; 0 &#125;; int k = 0; for (int i = 2; i &lt;= N; i++) &#123; for (int j = 2; j &lt;= sqrt(i); j++) &#123; if (i % j == 0) &#123; temp = 1; break; &#125; &#125; if (temp == 0) nums[i] = 1; temp = 0; &#125; for (int i = 2; i &lt;= N-2; i++) &#123; if (nums[i] == 1 &amp;&amp; nums[i + 2] == 1) count++; &#125; cout &lt;&lt; count; delete []nums; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1006 换个格式输出整数(c++解法)","slug":"PAT-Basic-Level-1006-换个格式输出整数(c++解法)","date":"2021-01-25T06:52:05.000Z","updated":"2021-01-25T09:01:08.259Z","comments":true,"path":"b313ab2d/","link":"","permalink":"https://blog.ccuwxy.cn/b313ab2d/","excerpt":"","text":"让我们用字母 B 来表示“百”、字母 S 表示“十”，用 12...n 来表示不为零的个位数字 n（&lt;10），换个格式来输出任一个不超过 3 位的正整数。例如 234 应该被输出为 BBSSS1234，因为它有 2 个“百”、3 个“十”、以及个位的 4。 输入格式：每个测试输入包含 1 个测试用例，给出正整数 n（&lt;1000）。 输出格式：每个测试用例的输出占一行，用规定的格式输出 n。 输入样例 1：1234 输出样例 1：1BBSSS1234 输入样例 2：123 输出样例 2：1SS123 代码123456789101112131415161718192021#include&lt;iostream&gt;using namespace std;int main()&#123; int n; cin &gt;&gt; n; int b = n / 100; int s = n % 100 / 10; int g = n % 10; while (b--) cout &lt;&lt; &#x27;B&#x27;; while (s--) cout &lt;&lt; &#x27;S&#x27;; for (int i = 1; i &lt;= g; i++) cout &lt;&lt; i; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"Visual Studio 2019 创建C++项目并运行","slug":"Visual-Studio-2019-创建C++项目并运行","date":"2021-01-18T14:11:00.000Z","updated":"2021-01-18T14:27:55.469Z","comments":true,"path":"7df02547/","link":"","permalink":"https://blog.ccuwxy.cn/7df02547/","excerpt":"","text":"1. 点击创建新项目 2. 选择创建空项目 3. 输入项目名称、位置与解决方案名称4. 在解决方案资源管理器中的源文件点击右键，添加新建项 5. 选择C++文件，修改文件名称，添加即可6. 输入示例代码后，点击本地Windows调试器，运行即可","categories":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"}],"tags":[{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"}]},{"title":"leetcode 7. 整数反转","slug":"leetcode-7.-整数反转","date":"2021-01-17T07:20:05.000Z","updated":"2021-01-17T08:00:02.549Z","comments":true,"path":"9c180c02/","link":"","permalink":"https://blog.ccuwxy.cn/9c180c02/","excerpt":"","text":"给出一个 32 位的有符号整数，你需要将这个整数中每位上的数字进行反转。 注意： 假设我们的环境只能存储得下 32 位的有符号整数，则其数值范围为 [−2^31^, 2^31^ − 1]。请根据这个假设，如果反转后整数溢出那么就返回 0。 示例 1：输入：x = 123输出：321 示例 2：输入：x = -123输出：-321 示例 3：输入：x = 120输出：21 示例 4：输入：x = 0输出：0 提示：-2^31^ &lt;= x &lt;= 2^31^ - 1 代码123456789101112131415class Solution &#123;public: int reverse(int x) &#123; long num = 0; while (x) &#123; num *= 10; num += (x % 10); x /= 10; &#125; return num &gt; INT_MAX || num &lt; INT_MIN ? 0 : num; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ccuwxy.cn/tags/leetcode/"}]},{"title":"leetcode 1. 两数之和","slug":"leetcode-1-两数之和","date":"2021-01-16T15:20:05.000Z","updated":"2021-01-17T06:37:30.621Z","comments":true,"path":"d9834ffe/","link":"","permalink":"https://blog.ccuwxy.cn/d9834ffe/","excerpt":"","text":"给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。 你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。 你可以按任意顺序返回答案。 示例 1：123输入：nums &#x3D; [2,7,11,15], target &#x3D; 9输出：[0,1]解释：因为 nums[0] + nums[1] &#x3D;&#x3D; 9 ，返回 [0, 1] 。 示例 2：12输入：nums &#x3D; [3,2,4], target &#x3D; 6输出：[1,2] 示例 3：12输入：nums &#x3D; [3,3], target &#x3D; 6输出：[0,1] 代码1：123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123; vector&lt;int&gt; result; for (int i = 0; i &lt; nums.size(); i++) &#123; for (int j = i+1; j &lt; nums.size(); j++) &#123; if (nums.at(i) + nums.at(j) == target) return &#123;i, j&#125;; &#125; &#125; return &#123;&#125;; &#125;&#125;; 代码2（使用哈希表）：123456789101112131415class Solution &#123;public: vector&lt;int&gt; twoSum1(vector&lt;int&gt;&amp; nums, int target) &#123; unordered_map&lt;int, int&gt; hash; for (int i = 0; i &lt; nums.size(); i++) &#123; auto it = hash.find(target - nums[i]); if (it != hash.end()) return &#123; it-&gt;second,i &#125;; hash[nums[i]] = i; &#125; return &#123;&#125;; &#125;&#125;;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ccuwxy.cn/tags/leetcode/"}]},{"title":"PAT Basic Level 1003 我要通过！(C++解法)","slug":"PAT-Basic-Level-1003-我要通过！(C++解法)","date":"2021-01-15T14:08:05.000Z","updated":"2021-01-15T14:27:14.799Z","comments":true,"path":"907368e/","link":"","permalink":"https://blog.ccuwxy.cn/907368e/","excerpt":"","text":"“答案正确”是自动判题系统给出的最令人欢喜的回复。本题属于 PAT 的“答案正确”大派送 —— 只要读入的字符串满足下列条件，系统就输出“答案正确”，否则输出“答案错误”。 得到“答案正确”的条件是： 字符串中必须仅有 P、 A、T这三种字符，不可以包含其它字符； 任意形如 xPATx 的字符串都可以获得“答案正确”，其中 x 或者是空字符串，或者是仅由字母 A 组成的字符串； 如果 aPbTc 是正确的，那么 aPbATca 也是正确的，其中 a、 b、 c 均或者是空字符串，或者是仅由字母 A 组成的字符串。现在就请你为 PAT 写一个自动裁判程序，判定哪些字符串是可以获得“答案正确”的。 输入格式：每个测试输入包含 1 个测试用例。第 1 行给出一个正整数 n (&lt;10)，是需要检测的字符串个数。接下来每个字符串占一行，字符串长度不超过 100，且不包含空格。 输出格式：每个字符串的检测结果占一行，如果该字符串可以获得“答案正确”，则输出 YES，否则输出 NO。 输入样例：1234567898PATPAATAAPATAAAAPAATAAAAxPATxPTWhateverAPAAATAA 输出样例：12345678YESYESYESYESNONONONO 代码及思路1234567891011121314151617181920212223242526272829303132333435363738394041424344454647//由题意得，P前面只能有A#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main()&#123; int n; string s; cin &gt;&gt; n; while (n--) &#123; cin &gt;&gt; s; size_t p = s.find_first_not_of(&#x27;A&#x27;); // 找到第一个不是A的位置 if (p == string::npos || s[p] != &#x27;P&#x27;) //如果全是A或者最后一个A的后面不是P，则答案错误 &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; size_t t = s.find_first_not_of(&#x27;A&#x27;, p + 1); // 从p+1位置开始找不是A的位置，其实就是找T的位置 if (t == string::npos || s[t] != &#x27;T&#x27; || t == p + 1) //最后一个连续A的下一个不存在，或者不是T，或者P后面直接就是T，答案错误 &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; size_t m = s.find_first_not_of(&#x27;A&#x27;, t + 1);// 为了判断T后面有几个A， if (m != string::npos) // 如果T后面不全是A，则答案错误 &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; if ((s.length() - 1 - t) == p * (t - p - 1)) //T后面A的个数 等于 P前面A的个数 乘 P、T之间A的个数减一（由条件三判断） &#123; cout &lt;&lt; &quot;YES&quot; &lt;&lt; endl; continue; &#125; else &#123; cout &lt;&lt; &quot;NO&quot; &lt;&lt; endl; continue; &#125; &#125; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1004 成绩排名(c++解法)","slug":"PAT-Basic-Level-1004-成绩排名(c++解法)","date":"2021-01-14T14:52:05.000Z","updated":"2021-01-14T16:53:35.797Z","comments":true,"path":"f863b9d/","link":"","permalink":"https://blog.ccuwxy.cn/f863b9d/","excerpt":"","text":"读入 n（&gt;0）名学生的姓名、学号、成绩，分别输出成绩最高和成绩最低学生的姓名和学号。 输入格式：每个测试输入包含 1 个测试用例，格式为 12345第 1 行：正整数 n第 2 行：第 1 个学生的姓名 学号 成绩第 3 行：第 2 个学生的姓名 学号 成绩 ... ... ...第 n+1 行：第 n 个学生的姓名 学号 成绩 其中姓名和学号均为不超过 10 个字符的字符串，成绩为 0 到 100 之间的一个整数，这里保证在一组测试用例中没有两个学生的成绩是相同的。 输出格式：对每个测试用例输出 2 行，第 1 行是成绩最高学生的姓名和学号，第 2 行是成绩最低学生的姓名和学号，字符串间有 1 空格。 输入样例：12343Joe Math990112 89Mike CS991301 100Mary EE990830 95 输出样例：12Mike CS991301Joe Math990112 思路首先将姓名、学号、成绩放到一个结构体中，把输入的数据按照分数排序，输出即可。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;struct stu&#123; char name[11]; //这里比最大位数大一，也许需要保存文件结尾标记 char no[11]; int score;&#125;;bool cmp(stu a, stu b) // 将stu结构体按照score排序&#123; return a.score &lt; b.score; //从小到大&#125;int main()&#123; int n; cin &gt;&gt; n; stu* stus = new stu[n]; for (int i = 0; i &lt; n; i++) &#123; cin &gt;&gt; stus[i].name &gt;&gt; stus[i].no &gt;&gt; stus[i].score; &#125; sort(stus, stus + n, cmp); cout &lt;&lt; stus[n - 1].name &lt;&lt; &quot; &quot; &lt;&lt; stus[n - 1].no &lt;&lt; endl; cout &lt;&lt; stus[0].name &lt;&lt; &quot; &quot; &lt;&lt; stus[0].no &lt;&lt; endl; delete[] stus; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1002 写出这个数(20分)","slug":"PAT-Basic-Level-1002-写出这个数(20分)","date":"2021-01-13T13:52:05.000Z","updated":"2021-01-14T16:53:35.796Z","comments":true,"path":"8edce93b/","link":"","permalink":"https://blog.ccuwxy.cn/8edce93b/","excerpt":"","text":"读入一个正整数 n，计算其各位数字之和，用汉语拼音写出和的每一位数字。 输入格式：每个测试输入包含 1 个测试用例，即给出自然数 n 的值。这里保证 n 小于 10^100 。 输出格式：在一行内输出 n 的各位数字之和的每一位，拼音数字间有 1 空格，但一行中最后一个拼音数字后没有空格。 输入样例：11234567890987654321123456789 输出样例：1yi san wu 思路输入数字最大100位，采用字符串输入，将每个字符对应的数字累加，按位取出累加和每位，将每位对应的拼音输出。 代码1234567891011121314151617181920212223242526272829303132#include&lt;iostream&gt;using namespace std;int main()&#123; string pinyin[10] = &#123; &quot;ling&quot;,&quot;yi&quot;,&quot;er&quot;,&quot;san&quot;,&quot;si&quot;,&quot;wu&quot;,&quot;liu&quot;,&quot;qi&quot;,&quot;ba&quot;,&quot;jiu&quot; &#125;; string N; cin &gt;&gt; N; int length = N.length(); int sum = 0; while (length) &#123; sum += (N[--length] - &#x27;0&#x27;); //在ASCII中字符与&#x27;0&#x27;字符的差值为对应的数字 &#125; char sumChar[3]; int sumIndex = 0; while (sum) &#123; sumChar[sumIndex++] = sum % 10; //存放的数字为逆序的 sum /= 10; &#125; for (int i = sumIndex - 1; i &gt;= 0; i--) &#123; cout &lt;&lt; pinyin[sumChar[i]]; if (i != 0) cout &lt;&lt; &quot; &quot;; &#125; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1001 害死人不偿命的(3n+1)猜想(15分)","slug":"PAT-Basic-Level-1001-害死人不偿命的(3n+1)猜想(15分)","date":"2021-01-13T13:20:05.000Z","updated":"2021-01-14T16:53:35.795Z","comments":true,"path":"ea4b0a04/","link":"","permalink":"https://blog.ccuwxy.cn/ea4b0a04/","excerpt":"","text":"卡拉兹(Callatz)猜想： 对任何一个正整数 n，如果它是偶数，那么把它砍掉一半；如果它是奇数，那么把 (3n+1) 砍掉一半。这样一直反复砍下去，最后一定在某一步得到 n=1。卡拉兹在 1950 年的世界数学家大会上公布了这个猜想，传说当时耶鲁大学师生齐动员，拼命想证明这个貌似很傻很天真的命题，结果闹得学生们无心学业，一心只证 (3n+1)，以至于有人说这是一个阴谋，卡拉兹是在蓄意延缓美国数学界教学与科研的进展…… 我们今天的题目不是证明卡拉兹猜想，而是对给定的任一不超过 1000 的正整数 n，简单地数一下，需要多少步（砍几下）才能得到 n=1？ 输入格式：每个测试输入包含 1 个测试用例，即给出正整数 n 的值。 输出格式：输出从 n 计算到 1 需要的步数。 输入样例：13 输出样例15 思路当n为偶数时，n变为n的一半；当n为奇数时，n变为3n+1的一半。记录n等于1需要运算的次数，输出即可。 代码1234567891011121314151617181920#include&lt;stdio.h&gt;int main()&#123; int count = 0; int N; scanf(&quot;%d&quot;, &amp;N); while (N != 1) &#123; if (N % 2 == 0) &#123; N /= 2; &#125; else &#123; N = (3 * N + 1) / 2; &#125; count++; &#125; printf(&quot;%d&quot;, count); return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1066 图像过滤(15分)","slug":"PAT-Basic-Level-1066-图像过滤(15分)","date":"2021-01-13T11:21:05.000Z","updated":"2021-01-14T16:53:35.798Z","comments":true,"path":"f1334a6c/","link":"","permalink":"https://blog.ccuwxy.cn/f1334a6c/","excerpt":"","text":"图像过滤是把图像中不重要的像素都染成背景色，使得重要部分被凸显出来。现给定一幅黑白图像，要求你将灰度值位于某指定区间内的所有像素颜色都用一种指定的颜色替换。 输入格式：输入在第一行给出一幅图像的分辨率，即两个正整数 M 和 N（0&lt;M,N≤500），另外是待过滤的灰度值区间端点 A 和 B（0≤A&lt;B≤255）、以及指定的替换灰度值。随后 M 行，每行给出 N 个像素点的灰度值，其间以空格分隔。所有灰度值都在 [0, 255] 区间内。 输出格式输出按要求过滤后的图像。即输出 M 行，每行 N 个像素灰度值，每个灰度值占 3 位（例如黑色要显示为 000），其间以一个空格分隔。行首尾不得有多余空格。 输入样例12343 5 100 150 03 189 254 101 119150 233 151 99 10088 123 149 0 255 输出样例123003 189 254 000 000000 233 151 099 000088 000 000 000 255 思路当灰度值在A-B区间时，将灰度值替换为指定的灰度值，每个灰度值输出三位，空位补0 代码12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;iomanip&gt;using namespace std;int main()&#123; int M, N, A, B, re; cin &gt;&gt; M &gt;&gt; N &gt;&gt; A &gt;&gt; B &gt;&gt; re; int* rgbs = new int[N]; for (int i = 0; i &lt; M; i++) &#123; for (int j = 0; j &lt; N; j++) &#123; cin &gt;&gt; rgbs[j]; if (rgbs[j] &gt;= A &amp;&amp; rgbs[j] &lt;= B) rgbs[j] = re; &#125; for (int j = 0; j &lt; N; j++) &#123; cout &lt;&lt; setw(3) &lt;&lt; setfill(&#x27;0&#x27;) &lt;&lt; rgbs[j]; if (j != N - 1) cout &lt;&lt; &quot; &quot;; &#125; cout &lt;&lt; endl; &#125; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"PAT Basic Level 1060 爱丁顿数 (25分)","slug":"PAT-Basic-Level-1060-爱丁顿数(25分)","date":"2021-01-13T03:01:00.000Z","updated":"2021-01-14T16:53:35.797Z","comments":true,"path":"d56ae534/","link":"","permalink":"https://blog.ccuwxy.cn/d56ae534/","excerpt":"","text":"英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式：输入第一行给出一个正整数 N (≤10^5)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式：在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 思路数据大小为10^5，不能使用O(N^2)时间复杂度的算法，采用先快排，再找爱丁顿数 废话不说了 上代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int N; cin &gt;&gt; N; int* nums = new int[N]; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + N); //从小到大快排 if (nums[0] &gt; N) //如果骑行距离最小对应的天数都大于骑行的天数，直接输出骑行的天数 cout &lt;&lt; N; else for (int i = N - 1; i &gt;= 0; i--) &#123; if (N - i &gt;= nums[i]) //找到天数大于等于元素值 &#123; cout &lt;&lt; N - i - 1; //去除当前元素对应的天数，输出天数-1 break; &#125; &#125; delete[] nums; return 0;&#125; 运行结果","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"解决Visual Studio 2019 下载扩展非常慢的问题！！！","slug":"解决Visual Studio 2019 下载扩展非常慢的问题！！！","date":"2021-01-13T02:30:00.000Z","updated":"2021-01-14T16:53:35.798Z","comments":true,"path":"a7f0f5d4/","link":"","permalink":"https://blog.ccuwxy.cn/a7f0f5d4/","excerpt":"","text":"解决思路（推荐使用下载工具下载到本地再安装）一、修改host文件（该方法效果因地理位置而不同）（不推荐） host文件位置：C:\\Windows\\System32\\drivers\\etc 通过站长工具http://tool.chinaz.com/dns 查询 download.visualstudio.microsoft.com 域名TTL值最小的IP地址 在最后一行加上 这个IP地址和域名122.188.0.118 download.visualstudio.microsoft.com 打开cmd命令行窗口 使用 ipconfig /flushdns 命令刷新DNS 重新下载扩展就可以了 二、使用下载工具下载到本地，再安装（推荐） 首先打开vs的管理扩展 在联机中找到想要下载的扩展，在右面栏中点击 详细信息 在网页中下载（推荐使用X雷等下载工具，会有P2P加速） 关闭VS，双击下载的文件安装即可","categories":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"}],"tags":[{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"}]},{"title":"计算机网络（一）","slug":"network","date":"2021-01-11T15:53:03.792Z","updated":"2021-01-14T16:53:00.356Z","comments":true,"path":"de1fcd2b/","link":"","permalink":"https://blog.ccuwxy.cn/de1fcd2b/","excerpt":"","text":"三次握手 第一次握手: client将标志位SYN置为1,随机产生一个值seq = J,并将该数据发送给server,client进入SYN_SENT状态,等待server确认 第二次握手: server收到数据包后由标志位SYN=1知道client 请求建立连接,server将标志位SYN和ACK都置为1, ack = J + 1, 随机产生一个值seq = K,并将该数据包发送给client以确认连接请求, server进入SYN_RCVD状态 第三次握手: client收到确认,检查ack是否为J+1， ACK是否为,如果正确则将标志位ACK置为1,ack = K+1, 并将该数据包发送给server, server检查ack是否为K+1, ACK是否为1,如果正确则连接建立成功, client和server进入ESTABLISHED状态,完成三次握手,随后client和server之间可以开始传输数据了 四次挥手 第一次挥手: client发送一个FIN,用来关闭client到server的数据传送,client进入FIN_WAIT_1状态 第二次挥手: server收到FIN后,发送一个ACK给client,确认序号为收到序号+1,server进入close_wait状态 第三次挥手: server发送一个FIN,用来关闭server到client的数据传送,server进入LAST_ACK状态 第四次挥手: client收到FIN后,client进入TIME_WAIT状态,接着发送一个ACK给server,确认序号为收到序号+1, server进入CLOSE状态,完成四次挥手 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 TCP和UDP区别 是否面向连接 传输可靠性 传输形式 传输效率 所需资源 应用场景 首部字节 TCP 面向连接 可靠 字节流 慢 多 要求传输可靠（文件传输） 20-60 UDP 无连接 不可靠 数据报文段 块 少 要求速度快（直播） 8字节 地址栏输入url到显示页面的过程 浏览器通过DNS查找域名对应的IP地址 浏览器向web服务器发送一个HTTP请求 服务器处理请求 服务器返回一个HTML响应 浏览器解析HTML渲染页面 状态码 类别 原因 1XX 信息状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 重定向状态码 需要进行附加操作 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器端错误状态码 服务器处理请求出错 Cookie和SessionCookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie一般用来存储用户信息，数据保存在客户端Session主要通过服务器记录用户的状态，数据保存在服务器 HTTP 和 HTTPS 的区别 端口：HTTP默认80端口；HTPS默认443端口； 完全性：HTTP协议运行在TCP上，所有的内容都是明文的；HTTPS是运行在SSL/TLS上的协议，所有的传输都经过了加密； 对称加密：密钥只有一个，加密解密同一个密码； 非对称加密：密钥是成对的，分为公钥和私钥，相对于对称加密，速度比较慢。 资源消耗：HTTP资源消耗比HTTPS资源消耗少。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://blog.ccuwxy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.ccuwxy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JVM","slug":"JVM","date":"2020-04-06T13:05:00.000Z","updated":"2021-01-14T16:53:00.349Z","comments":true,"path":"66c016fb/","link":"","permalink":"https://blog.ccuwxy.cn/66c016fb/","excerpt":"","text":"Java内存区域 JDK1.8之前： 线程共享：堆、方法区 线程私有：虚拟机栈、本地方法栈、程序计数器 JDK1.8： 线程共享：堆、元空间（直接内存） 线程私有：虚拟机栈、本地方法栈、程序计数器 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://blog.ccuwxy.cn/tags/JVM/"}]},{"title":"redis","slug":"redis","date":"2020-04-06T11:36:00.000Z","updated":"2021-01-14T16:53:00.356Z","comments":true,"path":"7b25d017/","link":"","permalink":"https://blog.ccuwxy.cn/7b25d017/","excerpt":"","text":"常用数据类型 String 常用命令: set,get,decr,incr,mget 等。 是简单的key-value类型。 Hash 常用命令: hget,hset,hgetall 等。 特别适合存储对象。 List 常用命令: lpush,rpush,lpop,rpop,lrange等。 list就是链表，可用作粉丝列表、消息列表 Set 常用命令: sadd,spop,smembers,sunion等。 set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。 Sorted Set 常用命令: zadd,zrange,zrem,zcard等。 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://blog.ccuwxy.cn/tags/redis/"}]},{"title":"MySQL和Oracle的区别","slug":"mysql-oracle","date":"2020-04-06T11:30:00.000Z","updated":"2021-01-14T16:53:00.355Z","comments":true,"path":"eae41e22/","link":"","permalink":"https://blog.ccuwxy.cn/eae41e22/","excerpt":"","text":"事务的提交 mysql默认自动提交事务 oracle默认手动提交事务，通过commit来提交 分页查询 mysql用limit进行分页 oracle用伪列rownum和嵌套查询 事务隔离级别 mysql默认repeatable read oracle默认read committed 对事务的支持 mysql只有在InnoDB引擎时才支持事务 oracle任何情况都支持事务","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.ccuwxy.cn/tags/Oracle/"}]},{"title":"MySQL联合索引(复合索引)的使用原则","slug":"mysql","date":"2020-04-06T11:30:00.000Z","updated":"2021-01-22T15:31:56.000Z","comments":true,"path":"c64d45f4/","link":"","permalink":"https://blog.ccuwxy.cn/c64d45f4/","excerpt":"","text":"ＭySQL联合 索引(复合索引)的使用原则命名规则：表名_字段名 需要加索引的字段，要在where条件中。 数据量少的字段不需要加索引。最窄的字段放在键的左边。 如果where条件中是OR关系，必须所有的or条件都必须是独立索引，否则加索引不起作用。 最左匹配原则。 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 聚簇索引与非聚簇索引（也叫二级索引） 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。","categories":[{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"联合索引","slug":"联合索引","permalink":"https://blog.ccuwxy.cn/tags/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"}]},{"title":"多线程（二）","slug":"thread02","date":"2020-04-05T14:05:00.000Z","updated":"2021-01-14T16:53:00.357Z","comments":true,"path":"36b886b6/","link":"","permalink":"https://blog.ccuwxy.cn/36b886b6/","excerpt":"","text":"ThreadLocal可以理解ThreadLocal是对ThreadLocalMap的封装，对ThreadLocal的set和get，其实都是对ThreadLocalMap的操作，Map的key是当前线程的Thread对象，值为Object对象。 ThreadLocal内存泄漏ThreadLocal 的key是弱引用，value是强引用，当ThreadLocal没有被外部强引用的时候，垃圾回收时，会把key清理掉，而value不会被清理掉，这样一来，value永远不会被回收，就造成了内存泄漏。 线程池池化技术只要是为了减少每次获取资源的消耗，提高对资源的利用率。 降低资源消耗。通过重复利用已经创建好的线程降低线程创建和销毁造成的资源消耗。 提高响应速度。不需要等待创建线程，直接在线程池中取线程。 提高线程的可管理性。线程池可以统一调配、调优、监控线程的使用。 实现Runnable接口和Callable接口的区别Runnable接口没有返回值，也不能抛出异常；而Callable接口有返回值，可以抛出异常。 ThreadPoolExecutor类分析123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; **corePoolSize**：核心线程数定义了最小可以同时运行的线程数量 **maximumPoolSize**：最大线程数。当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。 keepAliveTime：当线程池线程数量大于corePoolSize时，如果没有新的任务提交，核心线程外的线程不会被立即销毁，而是会等到超时时间过了keepAliveTime才会被销毁。 **workQueue**：当新任务来的时候，会先判断当前运行的线程数量是否达到核心线程数量，如果达到，就放入到队列中。 unit：keepAliveTime的时间单位。 threadFactory：executor创建新的线程时会用到。 handler：饱和策略。 ThreadPoolExecutor 饱和策略 **ThreadPoolExecutor.AbortPolicy**：抛出异常，拒绝新任务； **ThreadPoolExecutor.CallerRunsPolicy**：重试添加当前任务； ThreadPoolExecutor.DiscardPolicy： 丢掉当前任务； ThreadPoolExecutor.DiscardOldestPolicy： 丢掉最早未处理任务。 线程池原理首先提交任务，判断线程池满否，线程池满了，判断等待队列满否，等待队列满了，判断线程池满否，线程池满了，依照策略处理；线程池未满，创建线程；等待队列未满，加入到队列。 Atomic 原子类原子类是指一个操作是不可中断的，不会被其他的线程干扰。 原子类分类基本类型 AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型 AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新带有版本号的引用类型。 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 CAS原理CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。 AQS（AbstractQueuedSynchronizer）AQS在java.util.concurrent.locks包下，它是一个用来构建锁和同步器的框架，使用AQS可以简单高效的构造出应用广泛的同步器，比如ReentranLock。 AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 AQS两种资源共享方式 独占：只有一个线程能够执行。例如ReentrantLock。又可分为公平锁和非公平锁。 共享：多个线程可以同时执行。例如Semaphore。 AQS组件总结 Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 CountDownLatch（倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 CyclicBarrier(循环栅栏)： 实现线程间的技术等待。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]},{"title":"多线程（一）","slug":"thread01","date":"2020-04-04T14:05:00.000Z","updated":"2021-01-14T16:53:00.357Z","comments":true,"path":"6ae6a6e/","link":"","permalink":"https://blog.ccuwxy.cn/6ae6a6e/","excerpt":"","text":"进程？进程是程序的一次执行过程，是程序运行程序的基本单位，进程是动态的，程序的运行就是进程从创建到运行再到消亡的一个过程。 线程？线程和进程类似，线程是比进程更小的运行单位。一个进程的执行过程中可能会产生多个线程，同一个类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈、本地方法栈，在各个线程之间切换工作的负担要比进程小很多。 进程和线程的关系、区别、优缺点？线程是进程划分的更小的执行单位。他们最大的不同是 各个进程之间是独立的，而线程不一定。因为同一进程下的线程极有可能会相互影响。线程在切换时的开销要比进程小的多，但资源不利于管理，进程恰恰相反。 程序计数器为什么是私有的？程序计数器有以下两个作用： 程序计数器用来实现代码的流程控制。如：顺序执行、选择执行、循环执行。 在多线程的情况下，程序计数器可以记录当前线程执行到的位置，在线程切换回来的时候，知道执行到了哪里。 程序计数器是私有的是为了线程在切换回来时能够找到正确的执行位置。 虚拟机栈和本地方法栈为什么是私有的？虚拟机栈和本地方法栈私有为了保证线程中的局部变量不被其他线程访问到。 什么是堆和方法区？堆和方法区是线程共享的资源，堆是进程中最大的一块内存区域，主要用来存放新创建的对象，方法区用来存放已经被加载的类信息、常量、静态变量等数据。 并发和并行 并发： 同一时间段内，多个任务在执行； 并行： 同一个时间点，多个任务在执行。 为什要用多线程？ 从计算机底层来说： 线程可以比作轻量级的进程，是程序执行的最小单位，线程之间的上下文切换成本要比进程小得多。现在的CPU多数是多核心的，也就是多个线程可以同时运行，大大减少了上下文切换的开销。 互联网发展： 现在的系统经常有数百万，数千万的并发量，如果只用单线程肯定是扛不住的，多线程为高并发系统提供了基础，利用多线程层可以大大提高系统的应发能力。 多线程可能会带来哪些问题？在多线程的时候，可能会发生内存泄漏、上下文切换、死锁等问题。 线程的生命周期初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态 线程创建之后处于新建状态，调用了start()方法后处于可运行状态，当获取到了时间片后，处于运行状态。当线程执行了wait()方法后，处于等待状态，需要依靠其他线程来唤醒。当线程在没有获取到锁的时候，会处于阻塞状态，在执行run()方法后，会处于终止状态。 什么是死锁？死锁就是多个线程同时被阻塞，都在等待某个资源被释放。由于线程被无限期阻塞，就造成了死锁。 死锁需要具备的条件： 互斥条件：某资源同一时刻只能一个线程使用； 请求与保持条件：一个线程在请求资源被阻塞时，不会释放已获得资源； 不剥夺条件：一个线程已获得的资源，不能在未使用完之前被其他线程剥夺，只能自己使用完毕后释放； 循环等待条件：若干线程之间形成一种头尾相接的循环等待关系。 如何避免死锁？ 破坏互斥条件：（无法破坏锁的互斥） 破坏请求与保持条件：一次性申请所有资源； 破坏不剥夺条件：占用资源的线程如果获取不到资源，主动释放已经获得的资源； 破坏循环等待条件：按序申请资源。 sleep()和wait()的异同？ sleep()没有释放锁，而wait()释放了锁； 两者都可以暂停线程； wait()通常用来线程间的通讯，sleep()用来暂停执行； wait()在调用后不会自动苏醒，需要另一个线程来唤醒，sleep()在执行完后会自动苏醒，wait(long timeout)超时也会自动苏醒。 为什么我们要调用start()方法，不能直接调用run()方法？因为调用start()方法后，线程会进入到就绪状态，当有时间片的时候，会进入到运行状态；而run()只是个普通方法调用，会被当成普通方法执行。 synchronized关键字synchronized 关键字是用来解决多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或代码块在一个时间点 只有一个线程能访问执行。 synchronized关键字三种使用方式 修饰实例方法：对当前对象加锁 修饰静态方法：对当前类加锁 修饰代码块：对当前类加锁 JDK1.6之后synchronized关键字底层的优化偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除等等。 锁只能升级不能降级锁的四种状态： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 synchronized和ReentrantLock区别① 两者都是可重入锁 可重入锁指的是自己可以再次获取自己的内部锁。 ② synchronized依赖于JVM，而ReentrantLock依赖于API synchronized依赖于JVM层面实现的，而ReentrantLock需要Lock() 和unlock() 配合try/finally来实现的。 ③ ReentrantLock比 synchronized 增加了一些高级功能 ReentrantLock提供了一种等待锁的线程机制 ReentrantLock可以是公平锁也可以是非公平锁，synchronized只能是非公平锁。公平锁就是先等待的线程先获得锁。 volatile关键字1. Java内存模型在JDK1.2之前，Java的内存模型实现是总是从主存（共享内存）读取变量，不需要特别注意；但现在的内存模型实现，线程可以吧变量存在本地内存中，而不是从主存直接读取，这就可能造成主存中的变量被修改了，另一个线程还在使用内存中未被修改的数据进行操作。 2. 并发编程三个重要特性 原子性：一个操作或多次操作，要么全部执行，要么全部不执行，synchronized可以保证代码片段的原子性； 可见性：当一个线程对共享内存修改了，别的线程可以立即看到修改后的最新值； 有序性：代码在执行过程中的先后顺序，volatile关键字可以防止指令重排 3. synchronized关键字与volatile关键字区别 volatile关键字是线程同步的轻量级实现，性能要比synchronized关键字好，但是volatile只能修饰变量，而synchronized关键字可以修饰变量、方法、代码块； 多线程访问volatile关键字不会发生阻塞，而synchronized可能发生阻塞； volatile关键字能保证数据的可见性，不能保证数据的原子性，synchronized都可以保证； volatile关键字主要用来解决变量在多个线程之间的可见性，而synchronized关键字解决的是同步性。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]}],"categories":[{"name":"Visual Studio","slug":"Visual-Studio","permalink":"https://blog.ccuwxy.cn/categories/Visual-Studio/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://blog.ccuwxy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"},{"name":"数据库","slug":"数据库","permalink":"https://blog.ccuwxy.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"软件技巧","slug":"软件技巧","permalink":"https://blog.ccuwxy.cn/tags/%E8%BD%AF%E4%BB%B6%E6%8A%80%E5%B7%A7/"},{"name":"VS","slug":"VS","permalink":"https://blog.ccuwxy.cn/tags/VS/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"PAT","slug":"PAT","permalink":"https://blog.ccuwxy.cn/tags/PAT/"},{"name":"leetcode","slug":"leetcode","permalink":"https://blog.ccuwxy.cn/tags/leetcode/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.ccuwxy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JVM","slug":"JVM","permalink":"https://blog.ccuwxy.cn/tags/JVM/"},{"name":"redis","slug":"redis","permalink":"https://blog.ccuwxy.cn/tags/redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.ccuwxy.cn/tags/Oracle/"},{"name":"联合索引","slug":"联合索引","permalink":"https://blog.ccuwxy.cn/tags/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]}