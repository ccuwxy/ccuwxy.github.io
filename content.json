{"meta":{"title":"Hexo","subtitle":"","description":"","author":"wxy","url":"https://blog.ccuwxy.cn","root":"/"},"pages":[{"title":"404 Not Found：该页无法显示","date":"2021-01-11T15:40:31.076Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"/404.html","permalink":"https://blog.ccuwxy.cn/404.html","excerpt":"","text":""},{"title":"关于","date":"2021-01-11T17:19:44.041Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"about/index.html","permalink":"https://blog.ccuwxy.cn/about/index.html","excerpt":"","text":"个人详细介绍"},{"title":"书单","date":"2021-01-11T15:40:31.108Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"books/index.html","permalink":"https://blog.ccuwxy.cn/books/index.html","excerpt":"","text":""},{"title":"分类","date":"2021-01-11T15:40:31.141Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"categories/index.html","permalink":"https://blog.ccuwxy.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2021-01-11T14:56:09.028Z","updated":"2021-01-11T13:18:23.598Z","comments":true,"path":"links/index.html","permalink":"https://blog.ccuwxy.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2021-01-11T14:54:43.416Z","updated":"2021-01-11T14:54:42.000Z","comments":false,"path":"repository/index.html","permalink":"https://blog.ccuwxy.cn/repository/index.html","excerpt":"","text":"Githubgithub: username: ccuwxy # github username"},{"title":"标签","date":"2021-01-11T15:40:31.173Z","updated":"2021-01-11T13:18:23.598Z","comments":false,"path":"tags/index.html","permalink":"https://blog.ccuwxy.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"解决Visual Studio 2019 下载扩展非常慢的问题！！！","date":"2021-01-13T04:16:38.209Z","updated":"2021-01-13T03:40:34.000Z","comments":true,"path":"2021/01/13/解决Visual Studio 2019 下载扩展非常慢的问题！！！/","link":"","permalink":"https://blog.ccuwxy.cn/2021/01/13/%E8%A7%A3%E5%86%B3Visual%20Studio%202019%20%E4%B8%8B%E8%BD%BD%E6%89%A9%E5%B1%95%E9%9D%9E%E5%B8%B8%E6%85%A2%E7%9A%84%E9%97%AE%E9%A2%98%EF%BC%81%EF%BC%81%EF%BC%81/","excerpt":"","text":"https://image.ccuwxy.cn/解决Visual Studio 2019 下载扩展非常慢的问题！！！解决思路（推荐使用下载工具下载到本地再安装）一、修改host文件（该方法效果因地理位置而不同）（不推荐） host文件位置：C:\\Windows\\System32\\drivers\\etc 通过站长工具http://tool.chinaz.com/dns 查询 download.visualstudio.microsoft.com 域名TTL值最小的IP地址 在最后一行加上 这个IP地址和域名1122.188.0.118 download.visualstudio.microsoft.com 打开cmd命令行窗口 使用 ipconfig /flushdns 命令刷新DNS 重新下载扩展就可以了 二、使用下载工具下载到本地，再安装（推荐） 首先打开vs的管理扩展 在联机中找到想要下载的扩展，在右面栏中点击 详细信息 在网页中下载（推荐使用X雷等下载工具，会有P2P加速） 关闭VS，双击下载的文件安装即可","categories":[],"tags":[]},{"title":"PTA Basic Level 1060 爱丁顿数 (25分)","slug":"PTA Basic Level 1060 爱丁顿数 (25分)","date":"2021-01-13T03:01:00.000Z","updated":"2021-01-13T03:47:28.000Z","comments":true,"path":"2021/01/13/PTA Basic Level 1060 爱丁顿数 (25分)/","link":"","permalink":"https://blog.ccuwxy.cn/2021/01/13/PTA%20Basic%20Level%201060%20%E7%88%B1%E4%B8%81%E9%A1%BF%E6%95%B0%20(25%E5%88%86)/","excerpt":"","text":"PTA Basic Level 1060 爱丁顿数 (25分)英国天文学家爱丁顿很喜欢骑车。据说他为了炫耀自己的骑车功力，还定义了一个“爱丁顿数” E ，即满足有 E 天骑车超过 E 英里的最大整数 E。据说爱丁顿自己的 E 等于87。 现给定某人 N 天的骑车距离，请你算出对应的爱丁顿数 E（≤N）。 输入格式：输入第一行给出一个正整数 N (≤10^5)，即连续骑车的天数；第二行给出 N 个非负整数，代表每天的骑车距离。 输出格式：在一行中给出 N 天的爱丁顿数。 输入样例：12106 7 6 9 3 10 8 2 7 8 输出样例：16 思路数据大小为10^5，不能使用O(N^2)时间复杂度的算法，采用先快排，再找爱丁顿数 废话不说了 上代码123456789101112131415161718192021222324252627282930#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;int main()&#123; int N; cin &gt;&gt; N; int* nums = new int[N]; for (int i = 0; i &lt; N; i++) &#123; cin &gt;&gt; nums[i]; &#125; sort(nums, nums + N); //从小到大快排 if (nums[0] &gt; N) //如果骑行距离最小对应的天数都大于骑行的天数，直接输出骑行的天数 cout &lt;&lt; N; else for (int i = N - 1; i &gt;= 0; i--) &#123; if (N - i &gt;= nums[i]) //找到天数大于等于元素值 &#123; cout &lt;&lt; N - i - 1; //去除当前元素对应的天数，输出天数-1 break; &#125; &#125; delete[] nums; return 0;&#125;","categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://blog.ccuwxy.cn/tags/PTA/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"}]},{"title":"多线程（二）","slug":"thread02","date":"2020-04-09T13:05:00.000Z","updated":"2021-01-12T02:45:01.000Z","comments":true,"path":"2020/04/09/thread02/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/09/thread02/","excerpt":"","text":"ThreadLocal可以理解ThreadLocal是对ThreadLocalMap的封装，对ThreadLocal的set和get，其实都是对ThreadLocalMap的操作，Map的key是当前线程的Thread对象，值为Object对象。 ThreadLocal内存泄漏ThreadLocal 的key是弱引用，value是强引用，当ThreadLocal没有被外部强引用的时候，垃圾回收时，会把key清理掉，而value不会被清理掉，这样一来，value永远不会被回收，就造成了内存泄漏。 线程池池化技术只要是为了减少每次获取资源的消耗，提高对资源的利用率。 降低资源消耗。通过重复利用已经创建好的线程降低线程创建和销毁造成的资源消耗。 提高响应速度。不需要等待创建线程，直接在线程池中取线程。 提高线程的可管理性。线程池可以统一调配、调优、监控线程的使用。 实现Runnable接口和Callable接口的区别Runnable接口没有返回值，也不能抛出异常；而Callable接口有返回值，可以抛出异常。 ThreadPoolExecutor类分析123456789101112131415161718192021public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; **corePoolSize**：核心线程数定义了最小可以同时运行的线程数量 **maximumPoolSize**：最大线程数。当队列中存放的任务达到队列容量时，当前可以同时运行的线程数量变为最大线程数。 keepAliveTime：当线程池线程数量大于corePoolSize时，如果没有新的任务提交，核心线程外的线程不会被立即销毁，而是会等到超时时间过了keepAliveTime才会被销毁。 **workQueue**：当新任务来的时候，会先判断当前运行的线程数量是否达到核心线程数量，如果达到，就放入到队列中。 unit：keepAliveTime的时间单位。 threadFactory：executor创建新的线程时会用到。 handler：饱和策略。 ThreadPoolExecutor 饱和策略 **ThreadPoolExecutor.AbortPolicy**：抛出异常，拒绝新任务； **ThreadPoolExecutor.CallerRunsPolicy**：重试添加当前任务； ThreadPoolExecutor.DiscardPolicy： 丢掉当前任务； ThreadPoolExecutor.DiscardOldestPolicy： 丢掉最早未处理任务。 线程池原理首先提交任务，判断线程池满否，线程池满了，判断等待队列满否，等待队列满了，判断线程池满否，线程池满了，依照策略处理；线程池未满，创建线程；等待队列未满，加入到队列。 Atomic 原子类原子类是指一个操作是不可中断的，不会被其他的线程干扰。 原子类分类基本类型 AtomicInteger：整型原子类 AtomicLong：长整型原子类 AtomicBoolean：布尔型原子类 数组类型 AtomicIntegerArray：整型数组原子类 AtomicLongArray：长整型数组原子类 AtomicReferenceArray：引用类型数组原子类 引用类型 AtomicReference：引用类型原子类 AtomicStampedReference：原子更新带有版本号的引用类型。 AtomicMarkableReference ：原子更新带有标记位的引用类型 对象的属性修改类型 AtomicIntegerFieldUpdater：原子更新整形字段的更新器 AtomicLongFieldUpdater：原子更新长整形字段的更新器 CAS原理CAS (compare and swap) + volatile 和 native 方法来保证原子操作，从而避免 synchronized 的高开销，执行效率大为提升。CAS的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。 AQS（AbstractQueuedSynchronizer）AQS在java.util.concurrent.locks包下，它是一个用来构建锁和同步器的框架，使用AQS可以简单高效的构造出应用广泛的同步器，比如ReentranLock。 AQS核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制AQS是用CLH队列锁实现的，即将暂时获取不到锁的线程加入到队列中。 AQS两种资源共享方式 独占：只有一个线程能够执行。例如ReentrantLock。又可分为公平锁和非公平锁。 共享：多个线程可以同时执行。例如Semaphore。 AQS组件总结 Semaphore（信号量）-允许多个线程同时访问： synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量)可以指定多个线程同时访问某个资源。 CountDownLatch（倒计时器）： CountDownLatch是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。 CyclicBarrier(循环栅栏)： 实现线程间的技术等待。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]},{"title":"计算机网络（一）","slug":"net","date":"2020-04-06T13:10:00.000Z","updated":"2021-01-11T16:04:00.000Z","comments":true,"path":"2020/04/06/net/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/06/net/","excerpt":"","text":"三次握手\\1. 第一次握手: client将标志位SYN置为1,随机产生一个值seq = J,并将该数据发送给server,client进入SYN_SENT状态,等待server确认 2 第二次握手: server收到数据包后由标志位SYN=1知道client 请求建立连接,server将标志位SYN和ACK都置为1, ack = J + 1, 随机产生一个值seq = K,并将该数据包发送给client以确认连接请求, server进入SYN_RCVD状态 3 第三次握手: client收到确认,检查ack是否为J+1， ACK是否为,如果正确则将标志位ACK置为1,ack = K+1, 并将该数据包发送给server, server检查ack是否为K+1, ACK是否为1,如果正确则连接建立成功, client和server进入ESTABLISHED状态,完成三次握手,随后client和server之间可以开始传输数据了 四次挥手 \\1. 第一次挥手: client发送一个FIN,用来关闭client到server的数据传送,client进入FIN_WAIT_1状态 \\2. 第二次挥手: server收到FIN后,发送一个ACK给client,确认序号为收到序号+1,server进入close_wait状态 \\3. 第三次挥手: server发送一个FIN,用来关闭server到client的数据传送,server进入LAST_ACK状态 \\4. 第四次挥手: client收到FIN后,client进入TIME_WAIT状态,接着发送一个ACK给server,确认序号为收到序号+1, server进入CLOSE状态,完成四次挥手 为什么要四次挥手任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。 TCP和UDP区别 是否面向连接 传输可靠性 传输形式 传输效率 所需资源 应用场景 首部字节 TCP 面向连接 可靠 字节流 慢 多 要求传输可靠（文件传输） 20-60 UDP 无连接 不可靠 数据报文段 块 少 要求速度快（直播） 8字节 地址栏输入url到显示页面的过程 浏览器通过DNS查找域名对应的IP地址 浏览器向web服务器发送一个HTTP请求 服务器处理请求 服务器返回一个HTML响应 浏览器解析HTML渲染页面 状态码 类别 原因 1XX 信息状态码 接收的请求正在处理 2XX 成功状态码 请求正常处理完毕 3XX 重定向状态码 需要进行附加操作 4XX 客户端错误状态码 服务器无法处理请求 5XX 服务器端错误状态码 服务器处理请求出错 Cookie和SessionCookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。 Cookie一般用来存储用户信息，数据保存在客户端Session主要通过服务器记录用户的状态，数据保存在服务器 HTTP 和 HTTPS 的区别 端口：HTTP默认80端口；HTPS默认443端口； 完全性：HTTP协议运行在TCP上，所有的内容都是明文的；HTTPS是运行在SSL/TLS上的协议，所有的传输都经过了加密； 对称加密：密钥只有一个，加密解密同一个密码； 非对称加密：密钥是成对的，分为公钥和私钥，相对于对称加密，速度比较慢。 资源消耗：HTTP资源消耗比HTTPS资源消耗少。","categories":[{"name":"计算机基础","slug":"计算机基础","permalink":"https://blog.ccuwxy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.ccuwxy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"}]},{"title":"JVM","slug":"JVM","date":"2020-04-06T13:05:00.000Z","updated":"2021-01-12T02:43:18.000Z","comments":true,"path":"2020/04/06/JVM/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/06/JVM/","excerpt":"","text":"Java内存区域 JDK1.8之前： 线程共享：堆、方法区 线程私有：虚拟机栈、本地方法栈、程序计数器 JDK1.8： 线程共享：堆、元空间（直接内存） 线程私有：虚拟机栈、本地方法栈、程序计数器 程序计数器程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。 程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"https://blog.ccuwxy.cn/tags/JVM/"}]},{"title":"redis","slug":"redis","date":"2020-04-06T11:36:00.000Z","updated":"2021-01-12T02:44:43.000Z","comments":true,"path":"2020/04/06/redis/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/06/redis/","excerpt":"","text":"常用数据类型 String 常用命令: set,get,decr,incr,mget 等。 是简单的key-value类型。 Hash 常用命令: hget,hset,hgetall 等。 特别适合存储对象。 List 常用命令: lpush,rpush,lpop,rpop,lrange等。 list就是链表，可用作粉丝列表、消息列表 Set 常用命令: sadd,spop,smembers,sunion等。 set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。 Sorted Set 常用命令: zadd,zrange,zrem,zcard等。 和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.ccuwxy.cn/categories/Database/"}],"tags":[{"name":"redis","slug":"redis","permalink":"https://blog.ccuwxy.cn/tags/redis/"}]},{"title":"MySQL和Oracle的区别","slug":"mysql-oracle","date":"2020-04-06T11:30:00.000Z","updated":"2021-01-12T02:44:27.000Z","comments":true,"path":"2020/04/06/mysql-oracle/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/06/mysql-oracle/","excerpt":"","text":"事务的提交 mysql默认自动提交事务 oracle默认手动提交事务，通过commit来提交 分页查询 mysql用limit进行分页 oracle用伪列rownum和嵌套查询 事务隔离级别 mysql默认repeatable read oracle默认read committed 对事务的支持 mysql只有在InnoDB引擎时才支持事务 oracle任何情况都支持事务","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.ccuwxy.cn/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.ccuwxy.cn/tags/Oracle/"}]},{"title":"MySQL联合索引(复合索引)的使用原则","slug":"mysql","date":"2020-04-06T11:30:00.000Z","updated":"2021-01-13T04:02:37.000Z","comments":true,"path":"2020/04/06/mysql/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/06/mysql/","excerpt":"","text":"ＭySQL联合 索引(复合索引)的使用原则命名规则：表名_字段名 需要加索引的字段，要在where条件中。 数据量少的字段不需要加索引。最窄的字段放在键的左边。 如果where条件中是OR关系，必须所有的or条件都必须是独立索引，否则加索引不起作用。 最左匹配原则。 只要列中包含有NULL值都将不会被包含在索引中，复合索引中只要有一列含有NULL值，那么这一列对于此复合索引就是无效的。所以我们在数据库设计时不要让字段的默认值为NULL。 聚簇索引与非聚簇索引（也叫二级索引） 聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据 非聚簇索引：将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行。","categories":[{"name":"Database","slug":"Database","permalink":"https://blog.ccuwxy.cn/categories/Database/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"联合索引","slug":"联合索引","permalink":"https://blog.ccuwxy.cn/tags/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"}]},{"title":"多线程（一）","slug":"thread01","date":"2020-04-04T14:05:00.000Z","updated":"2021-01-12T02:44:55.000Z","comments":true,"path":"2020/04/04/thread01/","link":"","permalink":"https://blog.ccuwxy.cn/2020/04/04/thread01/","excerpt":"","text":"进程？进程是程序的一次执行过程，是程序运行程序的基本单位，进程是动态的，程序的运行就是进程从创建到运行再到消亡的一个过程。 线程？线程和进程类似，线程是比进程更小的运行单位。一个进程的执行过程中可能会产生多个线程，同一个类的多个线程共享进程的堆和方法区资源，但每个线程有自己的程序计数器、虚拟机栈、本地方法栈，在各个线程之间切换工作的负担要比进程小很多。 进程和线程的关系、区别、优缺点？线程是进程划分的更小的执行单位。他们最大的不同是 各个进程之间是独立的，而线程不一定。因为同一进程下的线程极有可能会相互影响。线程在切换时的开销要比进程小的多，但资源不利于管理，进程恰恰相反。 程序计数器为什么是私有的？程序计数器有以下两个作用： 程序计数器用来实现代码的流程控制。如：顺序执行、选择执行、循环执行。 在多线程的情况下，程序计数器可以记录当前线程执行到的位置，在线程切换回来的时候，知道执行到了哪里。 程序计数器是私有的是为了线程在切换回来时能够找到正确的执行位置。 虚拟机栈和本地方法栈为什么是私有的？虚拟机栈和本地方法栈私有为了保证线程中的局部变量不被其他线程访问到。 什么是堆和方法区？堆和方法区是线程共享的资源，堆是进程中最大的一块内存区域，主要用来存放新创建的对象，方法区用来存放已经被加载的类信息、常量、静态变量等数据。 并发和并行 并发： 同一时间段内，多个任务在执行； 并行： 同一个时间点，多个任务在执行。 为什要用多线程？ 从计算机底层来说： 线程可以比作轻量级的进程，是程序执行的最小单位，线程之间的上下文切换成本要比进程小得多。现在的CPU多数是多核心的，也就是多个线程可以同时运行，大大减少了上下文切换的开销。 互联网发展： 现在的系统经常有数百万，数千万的并发量，如果只用单线程肯定是扛不住的，多线程为高并发系统提供了基础，利用多线程层可以大大提高系统的应发能力。 多线程可能会带来哪些问题？在多线程的时候，可能会发生内存泄漏、上下文切换、死锁等问题。 线程的生命周期初始状态、运行状态、阻塞状态、等待状态、超时等待状态、终止状态 线程创建之后处于新建状态，调用了start()方法后处于可运行状态，当获取到了时间片后，处于运行状态。当线程执行了wait()方法后，处于等待状态，需要依靠其他线程来唤醒。当线程在没有获取到锁的时候，会处于阻塞状态，在执行run()方法后，会处于终止状态。 什么是死锁？死锁就是多个线程同时被阻塞，都在等待某个资源被释放。由于线程被无限期阻塞，就造成了死锁。 死锁需要具备的条件： 互斥条件：某资源同一时刻只能一个线程使用； 请求与保持条件：一个线程在请求资源被阻塞时，不会释放已获得资源； 不剥夺条件：一个线程已获得的资源，不能在未使用完之前被其他线程剥夺，只能自己使用完毕后释放； 循环等待条件：若干线程之间形成一种头尾相接的循环等待关系。 如何避免死锁？ 破坏互斥条件：（无法破坏锁的互斥） 破坏请求与保持条件：一次性申请所有资源； 破坏不剥夺条件：占用资源的线程如果获取不到资源，主动释放已经获得的资源； 破坏循环等待条件：按序申请资源。 sleep()和wait()的异同？ sleep()没有释放锁，而wait()释放了锁； 两者都可以暂停线程； wait()通常用来线程间的通讯，sleep()用来暂停执行； wait()在调用后不会自动苏醒，需要另一个线程来唤醒，sleep()在执行完后会自动苏醒，wait(long timeout)超时也会自动苏醒。 为什么我们要调用start()方法，不能直接调用run()方法？因为调用start()方法后，线程会进入到就绪状态，当有时间片的时候，会进入到运行状态；而run()只是个普通方法调用，会被当成普通方法执行。 synchronized关键字synchronized 关键字是用来解决多个线程之间访问资源的同步性，synchronized关键字可以保证被它修饰的方法或代码块在一个时间点 只有一个线程能访问执行。 synchronized关键字三种使用方式 修饰实例方法：对当前对象加锁 修饰静态方法：对当前类加锁 修饰代码块：对当前类加锁 JDK1.6之后synchronized关键字底层的优化偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除等等。 锁只能升级不能降级锁的四种状态： 无锁状态 偏向锁状态 轻量级锁状态 重量级锁状态 synchronized和ReentrantLock区别① 两者都是可重入锁 可重入锁指的是自己可以再次获取自己的内部锁。 ② synchronized依赖于JVM，而ReentrantLock依赖于API synchronized依赖于JVM层面实现的，而ReentrantLock需要Lock() 和unlock() 配合try/finally来实现的。 ③ ReentrantLock比 synchronized 增加了一些高级功能 ReentrantLock提供了一种等待锁的线程机制 ReentrantLock可以是公平锁也可以是非公平锁，synchronized只能是非公平锁。公平锁就是先等待的线程先获得锁。 volatile关键字1. Java内存模型在JDK1.2之前，Java的内存模型实现是总是从主存（共享内存）读取变量，不需要特别注意；但现在的内存模型实现，线程可以吧变量存在本地内存中，而不是从主存直接读取，这就可能造成主存中的变量被修改了，另一个线程还在使用内存中未被修改的数据进行操作。 2. 并发编程三个重要特性 原子性：一个操作或多次操作，要么全部执行，要么全部不执行，synchronized可以保证代码片段的原子性； 可见性：当一个线程对共享内存修改了，别的线程可以立即看到修改后的最新值； 有序性：代码在执行过程中的先后顺序，volatile关键字可以防止指令重排 3. synchronized关键字与volatile关键字区别 volatile关键字是线程同步的轻量级实现，性能要比synchronized关键字好，但是volatile只能修饰变量，而synchronized关键字可以修饰变量、方法、代码块； 多线程访问volatile关键字不会发生阻塞，而synchronized可能发生阻塞； volatile关键字能保证数据的可见性，不能保证数据的原子性，synchronized都可以保证； volatile关键字主要用来解决变量在多个线程之间的可见性，而synchronized关键字解决的是同步性。","categories":[{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"}],"tags":[{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"}]}],"categories":[{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/categories/%E7%AE%97%E6%B3%95/"},{"name":"Java","slug":"Java","permalink":"https://blog.ccuwxy.cn/categories/Java/"},{"name":"计算机基础","slug":"计算机基础","permalink":"https://blog.ccuwxy.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"},{"name":"Database","slug":"Database","permalink":"https://blog.ccuwxy.cn/categories/Database/"}],"tags":[{"name":"PTA","slug":"PTA","permalink":"https://blog.ccuwxy.cn/tags/PTA/"},{"name":"算法","slug":"算法","permalink":"https://blog.ccuwxy.cn/tags/%E7%AE%97%E6%B3%95/"},{"name":"Thread","slug":"Thread","permalink":"https://blog.ccuwxy.cn/tags/Thread/"},{"name":"计算机网络","slug":"计算机网络","permalink":"https://blog.ccuwxy.cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"JVM","slug":"JVM","permalink":"https://blog.ccuwxy.cn/tags/JVM/"},{"name":"redis","slug":"redis","permalink":"https://blog.ccuwxy.cn/tags/redis/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.ccuwxy.cn/tags/MySQL/"},{"name":"Oracle","slug":"Oracle","permalink":"https://blog.ccuwxy.cn/tags/Oracle/"},{"name":"联合索引","slug":"联合索引","permalink":"https://blog.ccuwxy.cn/tags/%E8%81%94%E5%90%88%E7%B4%A2%E5%BC%95/"}]}